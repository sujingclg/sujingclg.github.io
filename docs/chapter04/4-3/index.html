<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="4.3 视线的计算 #  Computing View Rays
 我们已经在前面的部分中学习到了光线产生的基本工具是观察点（或者说观察方向）和成像平面。有很多方法计算摄像机几何的细节；在本节中，我们将阐述一种基于标准正交基(orthonormal bases)的方法，它可以支持常规视图、倾斜平行视图和正交视图。
为了生成射线，我们首先需要一个射线的数学表达式。射线实际上只是一个原点和一个传播方向；一个三维参数线就是个理想的射线。正如我们在2.7.7节讨论的那样，成像平面上从眼睛e发出，经过点s的三维参数线(图4.6)由下式定义：
  \[{\rm p}(t) = {\rm e} + t ({\rm s} - {\rm e})\]  图4.6 从人眼发出的射线穿过图像平面上一点 上式应该以这种方式解读：“我们从e沿着向量(s-e)前进t个距离来找到点p”。所以给定一个t，我们可以定义一个点p。点e是是射线的起点，s-e是射线的方向。
注意，p(0) = e，p(1) = s，更一般的，如果0 < t~1~ < t~2~，那么p(t~1~)将比p(t~2~)距离眼睛更近。同样地，如果t < 0，那么p(t)将在眼睛的“后方”。这些事实在我们查找视线范围内的（不在眼睛后方）、被光线照射到的、离观察者最近的物体时会很有用。
注意：我们对变量 t 进行了重载，它是射线的参数，也是图像顶部边缘的v坐标(v-coordinate)。  光线在代码中总是使用某种存储了位置和方向的结构体或对象来表示。例如，在一个object-oriented程序中我们可能写出如下程序：
class Ray Vec3 o | ray origin Vec3 d | ray direction Vec3 evaluate(real t) return o + td 我们假定Vec3类表示了一个三维向量，并且支持常规的算术运算。
为了计算一个视线(viewing ray)，我们需要知道 e (已经给出) 和 s 。求解 s 似乎很复杂，但如果我们从正确的坐标系下看此问题，就会发现他实际上是显而易见的。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="4.3 视线的计算"><meta property="og:description" content="4.3 视线的计算 #  Computing View Rays
 我们已经在前面的部分中学习到了光线产生的基本工具是观察点（或者说观察方向）和成像平面。有很多方法计算摄像机几何的细节；在本节中，我们将阐述一种基于标准正交基(orthonormal bases)的方法，它可以支持常规视图、倾斜平行视图和正交视图。
为了生成射线，我们首先需要一个射线的数学表达式。射线实际上只是一个原点和一个传播方向；一个三维参数线就是个理想的射线。正如我们在2.7.7节讨论的那样，成像平面上从眼睛e发出，经过点s的三维参数线(图4.6)由下式定义：
  \[{\rm p}(t) = {\rm e} + t ({\rm s} - {\rm e})\]  图4.6 从人眼发出的射线穿过图像平面上一点 上式应该以这种方式解读：“我们从e沿着向量(s-e)前进t个距离来找到点p”。所以给定一个t，我们可以定义一个点p。点e是是射线的起点，s-e是射线的方向。
注意，p(0) = e，p(1) = s，更一般的，如果0 < t~1~ < t~2~，那么p(t~1~)将比p(t~2~)距离眼睛更近。同样地，如果t < 0，那么p(t)将在眼睛的“后方”。这些事实在我们查找视线范围内的（不在眼睛后方）、被光线照射到的、离观察者最近的物体时会很有用。
注意：我们对变量 t 进行了重载，它是射线的参数，也是图像顶部边缘的v坐标(v-coordinate)。  光线在代码中总是使用某种存储了位置和方向的结构体或对象来表示。例如，在一个object-oriented程序中我们可能写出如下程序：
class Ray Vec3 o | ray origin Vec3 d | ray direction Vec3 evaluate(real t) return o + td 我们假定Vec3类表示了一个三维向量，并且支持常规的算术运算。
为了计算一个视线(viewing ray)，我们需要知道 e (已经给出) 和 s 。求解 s 似乎很复杂，但如果我们从正确的坐标系下看此问题，就会发现他实际上是显而易见的。"><meta property="og:type" content="article"><meta property="og:url" content="https://sujingclg.github.io/docs/chapter04/4-3/"><meta property="article:section" content="docs"><title>4.3 视线的计算 | 计算机图形学基础</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.ab46de3e725a6415339a37bba23a0067534a37289b063c9f8d011515a63097a8.css integrity="sha256-q0bePnJaZBUzmje7ojoAZ1NKNyibBjyfjQEVFaYwl6g=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.ba21324315b869c3638ea99918c07b1e84ec935ebd281e00189aec9bd6c24c47.js integrity="sha256-uiEyQxW4acNjjqmZGMB7HoTsk169KB4AGJrsm9bCTEc=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>计算机图形学基础</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-903d3e7635db560eef69c6ad03432b92 class=toggle>
<label for=section-903d3e7635db560eef69c6ad03432b92 class="flex justify-between"><a href=/docs/chapter01/>第1章 引言</a></label><ul><li><a href=/docs/chapter01/1-1/>1.1 图形学领域</a></li><li><a href=/docs/chapter01/1-7/>1.7 设计和开发图形程序</a></li></ul></li><li><input type=checkbox id=section-144f7b511d4fbbff231a670ff00b5f9e class=toggle>
<label for=section-144f7b511d4fbbff231a670ff00b5f9e class="flex justify-between"><a href=/docs/chapter02/>第2章 基本数学知识</a></label><ul></ul></li><li><input type=checkbox id=section-fca257306a653a028d58c47b763ab4c5 class=toggle>
<label for=section-fca257306a653a028d58c47b763ab4c5 class="flex justify-between"><a href=/docs/chapter03/>第3章 光栅化图像</a></label><ul><li><a href=/docs/chapter03/3-1/>3.1 光栅化设备</a></li></ul></li><li><input type=checkbox id=section-914c3bbb8c3fc1ae1705d7c0f585a4ae class=toggle checked>
<label for=section-914c3bbb8c3fc1ae1705d7c0f585a4ae class="flex justify-between"><a href=/docs/chapter04/>第4章 光线追踪</a></label><ul><li><a href=/docs/chapter04/4-1/>4.1 基础光线追踪算法</a></li><li><a href=/docs/chapter04/4-2/>4.2 透视投影</a></li><li><a href=/docs/chapter04/4-3/ class=active>4.3 视线的计算</a></li><li><a href=/docs/chapter04/4-4/>4.4 光线对象求交</a></li></ul></li><li class=book-section-flat><a href=/docs/example/>Example Site</a><ul><li><a href=/docs/example/table-of-contents/>Table of Contents</a><ul><li><a href=/docs/example/table-of-contents/with-toc/>With ToC</a></li><li><a href=/docs/example/table-of-contents/without-toc/>Without ToC</a></li></ul></li><li><input type=checkbox id=section-4e46b01272d410b3a99461d79326ddf4 class=toggle>
<label for=section-4e46b01272d410b3a99461d79326ddf4 class="flex justify-between"><a role=button>Collapsed</a></label><ul><li><a href=/docs/example/collapsed/3rd-level/>3rd Level</a><ul><li><a href=/docs/example/collapsed/3rd-level/4th-level/>4th Level</a></li></ul></li></ul></li></ul></li><li class=book-section-flat><span>Notes</span><ul><li><input type=checkbox id=section-09a42c31eb0974d53fdffb3236ecd72c class=toggle>
<label for=section-09a42c31eb0974d53fdffb3236ecd72c class="flex justify-between"><a role=button>Games 101</a></label><ul><li><a href=/docs/notes/games101/rasterization/>光栅化</a></li><li><a href=/docs/notes/games101/shading/>着色</a></li><li><a href=/docs/notes/games101/ray-tracing/>光线追踪</a></li><li><a href=/docs/notes/games101/path-racing/>路径追踪</a></li></ul></li><li><input type=checkbox id=section-d29b041f99d42b202964e7d69335c343 class=toggle>
<label for=section-d29b041f99d42b202964e7d69335c343 class="flex justify-between"><a role=button>Games 202</a></label><ul></ul></li></ul></li><li class=book-section-flat><span>Shortcodes</span><ul><li><a href=/docs/shortcodes/buttons/>Buttons</a></li><li><a href=/docs/shortcodes/columns/>Columns</a></li><li><a href=/docs/shortcodes/details/>Details</a></li><li><a href=/docs/shortcodes/expand/>Expand</a></li><li><a href=/docs/shortcodes/hints/>Hints</a></li><li><a href=/docs/shortcodes/katex/>Katex</a></li><li><a href=/docs/shortcodes/mermaid/>Mermaid</a></li><li><input type=checkbox id=section-d3fc1bf6d66cd84b896a0af9f40cb1d5 class=toggle>
<label for=section-d3fc1bf6d66cd84b896a0af9f40cb1d5 class="flex justify-between"><a href=/docs/shortcodes/section/>Section</a></label><ul><li><a href=/docs/shortcodes/section/first-page/>First Page</a></li><li><a href=/docs/shortcodes/section/second-page/>Second Page</a></li></ul></li><li><a href=/docs/shortcodes/tabs/>Tabs</a></li></ul></li></ul><ul><li><a href=/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>4.3 视线的计算</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#431-正交视图>4.3.1 正交视图</a></li><li><a href=#432-透视图>4.3.2 透视图</a></li></ul></nav></aside></header><article class=markdown><h1 id=43-视线的计算>4.3 视线的计算
<a class=anchor href=#43-%e8%a7%86%e7%ba%bf%e7%9a%84%e8%ae%a1%e7%ae%97>#</a></h1><p>Computing View Rays</p><hr><p>我们已经在前面的部分中学习到了光线产生的基本工具是观察点（或者说观察方向）和成像平面。有很多方法计算摄像机几何的细节；在本节中，我们将阐述一种基于标准正交基(orthonormal bases)的方法，它可以支持常规视图、倾斜平行视图和正交视图。</p><p>为了生成射线，我们首先需要一个射线的数学表达式。射线实际上只是一个原点和一个传播方向；一个三维参数线就是个理想的射线。正如我们在2.7.7节讨论的那样，成像平面上从眼睛e发出，经过点s的三维参数线(图4.6)由下式定义：</p><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>
\[{\rm p}(t) = {\rm e} + t ({\rm s} - {\rm e})\]</span>
<center style="font-size: 14px">图4.6 从人眼发出的射线穿过图像平面上一点</center><p>上式应该以这种方式解读：“我们从e沿着向量(s-e)前进t个距离来找到点p”。所以给定一个t，我们可以定义一个点p。点e是是射线的起点，s-e是射线的方向。</p><p>注意，p(0) = e，p(1) = s，更一般的，如果0 &lt; t~1~ &lt; t~2~，那么p(t~1~)将比p(t~2~)距离眼睛更近。同样地，如果t &lt; 0，那么p(t)将在眼睛的“后方”。这些事实在我们查找视线范围内的（不在眼睛后方）、被光线照射到的、离观察者最近的物体时会很有用。</p><blockquote class="book-hint info">注意：我们对变量 t 进行了重载，它是射线的参数，也是图像顶部边缘的v坐标(v-coordinate)。</blockquote><p>光线在代码中总是使用某种存储了位置和方向的结构体或对象来表示。例如，在一个object-oriented程序中我们可能写出如下程序：</p><pre tabindex=0><code>class Ray
    Vec3 o | ray origin
    Vec3 d | ray direction
    Vec3 evaluate(real t)
    return o + td
</code></pre><p>我们假定Vec3类表示了一个三维向量，并且支持常规的算术运算。</p><p>为了计算一个视线(viewing ray)，我们需要知道 e (已经给出) 和 s 。求解 s 似乎很复杂，但如果我们从正确的坐标系下看此问题，就会发现他实际上是显而易见的。</p><p>所有我们的射线生成方法都源自于一个正交坐标系，被称为相机坐标系(camera frame)（图4.7），在图中我们标记为e，作为观察点，同时u，v和w作为三个基础向量，分别指向右边、上边和后边，三个基向量正好形成了一个右手坐标系。最常见的构造相机坐标系的方法是用观察点(e)，观察方向(w)，和上矢量(up vector)（用于在观察方向和向上方向定义的平面上构造一个具有v和w的基），使用2.4.7节描述的从两个向量构造标准正交基的过程去构造相机坐标系（图4.8）。</p><center style="font-size: 14px">图4.7 屏幕上的采样点被映射到3D窗口上的一个类似的数组。一束观察射线射向了这些位置上的每个点。</center>
<center style="font-size: 14px">图4.8 相机坐标系的矢量，以及观察方向和向上方向。向量w与观察方向相反，向量v与向量w和上矢量(up vector)共面。</center><blockquote class="book-hint info">因为v和w必须是垂直的，上矢量(up vector)和v通常并不相同。但在场景中让上矢量直接指向上方，会使摄像机以我们认为的“垂直向上”的方式定向。</blockquote><br><h2 id=431-正交视图>4.3.1 正交视图
<a class=anchor href=#431-%e6%ad%a3%e4%ba%a4%e8%a7%86%e5%9b%be>#</a></h2><p>Orthographic Views</p><hr><p>对于一个正交视图，所有的光线都有一个共同的方向 &mdash; w。即使平行视图本身没有任何观察点，我们仍然可以使用相机框架的原点来定义光线开始的平面，这样物体就有可能在相机后面。</p><p>视线应从e点和响亮u，v定义的平面开始；唯一遗留的必要信息是假定图像在平面上的哪里，我们将使用四个数字定义图像的四条边：l 和 r 是图像的左边和右边的位置，他们是从e开始沿着u方向度量的；b 和 t 是底边和顶边的位置，他们是从e开始沿着v方向度量的。通常，l &lt; 0 &lt; r 且 b &lt; 0 &lt; t （图4.9a）。</p><center style="font-size: 14px">图4.9 使用相机坐标(camera frame)生成光线。(a) 在正交投影中，每根光线起始于成像平面上像素的位置，并且所有光线的方向和观察方向相同。(b)在透视投影中，每根光线起始于观察点(viewpoint)，并且每根光线由穿过观察点 e 和成像平面上的像素位置的直线定义。</center><p>在3.2节，我们讨论了一张图像的像素坐标。为了将n~x~ × n~y~像素的图像适配到尺寸为(r - l) × (t - b)的矩形中，设置这些像素的水平间距为a，垂直间距为b，边缘周围有半像素距离以使图像矩形内的像素网格居中。这意味着光栅图上(i,j)位置处的像素的位置如下：</p><span>\[\begin{aligned}u = l + (r-l)(i+0.5)/n_x \\v = b + (t-b)(j+0.5)/n_y\end{aligned}\tag {4.1}\]</span><p>其中(u, v)是图像平面上，根据原点e和基础向量{u, v}度量的像素位置的坐标。</p><blockquote class="book-hint info">正交视图中的光线应起始于无限远处似乎是合理的，但是它无法实现某些正交视图，例如一个房间里有一个物体的正交视图。</blockquote><blockquote class="book-hint info">许多系统假设l = -r 且 b = -l ，以便满足宽和高的要求。</blockquote><blockquote class="book-hint info">当 l 和 r 都指定时会有冗余：将观察点向右移动一小段距离，同时相应地减小 l 和 r ，不会改变视图（在v轴上操作也是如此）。</blockquote><p>在正交视图中，我们可以简单的使用像素的图像平面位置作为光线的起始点，并且我们已经知道了光线的方向是观察方向。生成正交视图光线的步骤如下：</p><pre tabindex=0><code>compute u and v using (4.1)
ray.o &lt;- e + uu + vv
ray.d &lt;- -w
</code></pre><p>实现倾斜的平行视图是非常简单的：只需将图像平面法线w与视图方向d分开。其生成过程与前述极为相似，只是用d替代 -w。当然，w仍然用于构建u和v。</p><br><h2 id=432-透视图>4.3.2 透视图
<a class=anchor href=#432-%e9%80%8f%e8%a7%86%e5%9b%be>#</a></h2><p>Perspective view</p><hr><p>在透视图中，所有的光线都有一个在viewpoint的原点；他在每个像素处的方向都是不同的。图像平面不在指向e，而是离e右一些距离d；这个距离是图像平面的距离，通常被误称为焦距(focal length)，因为对d的选取和照相机中对焦距的选取是一样的。视点和图像平面上像素的位置定义了每条光线的方向。这种情况见图4.9，其结果与正交视图的方法类似：</p><pre tabindex=0><code>compute u and v using (4.1)
ray.o &lt;- e
ray.d &lt;- -dw + uu + vv
</code></pre><p>与平行投影一样，可以通过将图像平面的法线与投影方向分离开来实现倾斜的透视图。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#431-正交视图>4.3.1 正交视图</a></li><li><a href=#432-透视图>4.3.2 透视图</a></li></ul></nav></div></aside></main></body></html>