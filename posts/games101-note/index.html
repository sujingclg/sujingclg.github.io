<!doctype html><html lang=en-us dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="之前的内容
从长宽比和垂直方向的可视角度可以推算出水平方向的可视角度。此外也可推算出正交投影的远近、左右、上下信息。
光栅化 (Rasterization) #  离散化三角形 (Triangles) #    What is a screen?
 An array of pixels Size of the array: resolution A typical kind of raster display    Raster == screen in German（屏幕的德语词汇）
 Rasterize == drawing onto the screen    Pixel (FYI, short for “picture element”)
 For now: A pixel is a little square with uniform color Color is a mixture of (red, green, blue)    光栅化步骤 #    从变换空间[-1,1]^3^映射到到屏幕空间。首先忽略z方向，使用视口变换将xy空间映射到屏幕。">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content="Games101 笔记">
<meta property="og:description" content="之前的内容
从长宽比和垂直方向的可视角度可以推算出水平方向的可视角度。此外也可推算出正交投影的远近、左右、上下信息。
光栅化 (Rasterization) #  离散化三角形 (Triangles) #    What is a screen?
 An array of pixels Size of the array: resolution A typical kind of raster display    Raster == screen in German（屏幕的德语词汇）
 Rasterize == drawing onto the screen    Pixel (FYI, short for “picture element”)
 For now: A pixel is a little square with uniform color Color is a mixture of (red, green, blue)    光栅化步骤 #    从变换空间[-1,1]^3^映射到到屏幕空间。首先忽略z方向，使用视口变换将xy空间映射到屏幕。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sujingclg.github.io/posts/games101-note/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-02-03T00:00:00+00:00">
<meta property="article:modified_time" content="2022-02-03T00:00:00+00:00">
<title>Games101 笔记 | 计算机图形学基础</title><link rel=manifest href=/manifest.json>
<link rel=icon href=/favicon.png type=image/x-icon>
<link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous>
<script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.ddcd5b07a5d9a059a4d4cedecd36d848e00c7f9eee7204dab211cb48e13bd6c1.js integrity="sha256-3c1bB6XZoFmk1M7ezTbYSOAMf57ucgTashHLSOE71sE=" crossorigin=anonymous></script>
</head><body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/><span>计算机图形学基础</span>
</a>
</h2><div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul>
<li>
<input type=checkbox id=section-903d3e7635db560eef69c6ad03432b92 class=toggle>
<label for=section-903d3e7635db560eef69c6ad03432b92 class="flex justify-between">
<a href=/docs/chapter01/>第1章 引言</a>
</label>
<ul>
<li>
<a href=/docs/chapter01/1-1/>1.1 图形学领域</a>
</li><li>
<a href=/docs/chapter01/1-7/>1.7 设计和开发图形程序</a>
</li></ul></li><li>
<input type=checkbox id=section-144f7b511d4fbbff231a670ff00b5f9e class=toggle>
<label for=section-144f7b511d4fbbff231a670ff00b5f9e class="flex justify-between">
<a href=/docs/chapter02/>第2章 基本数学知识</a>
</label>
<ul>
</ul></li><li>
<input type=checkbox id=section-fca257306a653a028d58c47b763ab4c5 class=toggle>
<label for=section-fca257306a653a028d58c47b763ab4c5 class="flex justify-between">
<a href=/docs/chapter03/>第3章 光栅化图像</a>
</label>
<ul>
<li>
<a href=/docs/chapter03/3-1/>3.1 光栅化设备</a>
</li></ul></li><li>
<input type=checkbox id=section-914c3bbb8c3fc1ae1705d7c0f585a4ae class=toggle>
<label for=section-914c3bbb8c3fc1ae1705d7c0f585a4ae class="flex justify-between">
<a href=/docs/chapter04/>第4章 光线追踪</a>
</label>
<ul>
<li>
<a href=/docs/chapter04/4-1/>4.1 基础光线追踪算法</a>
</li><li>
<a href=/docs/chapter04/4-2/>4.2 透视投影</a>
</li><li>
<a href=/docs/chapter04/4-3/>4.3 视线的计算</a>
</li><li>
<a href=/docs/chapter04/4-4/>4.4 光线对象相交</a>
</li></ul></li><li class=book-section-flat>
<a href=/docs/example/>Example Site</a>
<ul>
<li>
<a href=/docs/example/table-of-contents/>Table of Contents</a>
<ul>
<li>
<a href=/docs/example/table-of-contents/with-toc/>With ToC</a>
</li><li>
<a href=/docs/example/table-of-contents/without-toc/>Without ToC</a>
</li></ul></li><li>
<input type=checkbox id=section-4e46b01272d410b3a99461d79326ddf4 class=toggle>
<label for=section-4e46b01272d410b3a99461d79326ddf4 class="flex justify-between">
<a role=button>Collapsed</a>
</label>
<ul>
<li>
<a href=/docs/example/collapsed/3rd-level/>3rd Level</a>
<ul>
<li>
<a href=/docs/example/collapsed/3rd-level/4th-level/>4th Level</a>
</li></ul></li></ul></li></ul></li><li class=book-section-flat>
<span>Shortcodes</span>
<ul>
<li>
<a href=/docs/shortcodes/buttons/>Buttons</a>
</li><li>
<a href=/docs/shortcodes/columns/>Columns</a>
</li><li>
<a href=/docs/shortcodes/details/>Details</a>
</li><li>
<a href=/docs/shortcodes/expand/>Expand</a>
</li><li>
<a href=/docs/shortcodes/hints/>Hints</a>
</li><li>
<a href=/docs/shortcodes/katex/>Katex</a>
</li><li>
<a href=/docs/shortcodes/mermaid/>Mermaid</a>
</li><li>
<input type=checkbox id=section-d3fc1bf6d66cd84b896a0af9f40cb1d5 class=toggle>
<label for=section-d3fc1bf6d66cd84b896a0af9f40cb1d5 class="flex justify-between">
<a href=/docs/shortcodes/section/>Section</a>
</label>
<ul>
<li>
<a href=/docs/shortcodes/section/first-page/>First Page</a>
</li><li>
<a href=/docs/shortcodes/section/second-page/>Second Page</a>
</li></ul></li><li>
<a href=/docs/shortcodes/tabs/>Tabs</a>
</li></ul></li></ul><ul>
<li>
<a href=/posts/>
Blog
</a>
</li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div></aside><div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>Games101 笔记</strong>
<label for=toc-control>
<img src=/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div><aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#离散化三角形--triangles>离散化三角形 (Triangles)</a>
<ul>
<li><a href=#光栅化步骤>光栅化步骤</a></li></ul></li><li><a href=#反走样与深度缓冲>反走样与深度缓冲</a>
<ul>
<li><a href=#走样造成的负面效果>走样造成的负面效果</a></li><li><a href=#反走样的措施>反走样的措施</a></li><li><a href=#模糊处理的方法>模糊处理的方法</a></li><li><a href=#从频域角度分析走样产生的原因>从频域角度分析走样产生的原因</a></li><li><a href=#z-buffer>Z-Buffer</a></li></ul></li></ul><ul>
<li><a href=#blinn-phong-reflectance-model>Blinn-Phong Reflectance Model</a>
<ul>
<li><a href=#漫反射---diffuse>漫反射 - Diffuse</a></li><li><a href=#高光---specular-term>高光 - Specular Term</a></li><li><a href=#环境光---ambient>环境光 - Ambient</a></li><li><a href=#最终的blinn-phong反射模型公式>最终的Blinn-Phong反射模型公式</a></li></ul></li><li><a href=#着色频率--shading-frequencies>着色频率 (Shading Frequencies)</a>
<ul>
<li><a href=#shade-each-triangle-flat-shading>Shade each triangle (Flat shading)</a></li><li><a href=#shade-each-vertex-gouraud-shading>Shade each vertex (Gouraud shading)</a></li><li><a href=#shade-each-pixel-phong-shading>Shade each pixel (Phong shading)</a></li></ul></li><li><a href=#图形管线实时渲染>图形管线(实时渲染)</a></li><li><a href=#纹理映射--texture-mapping>纹理映射 (Texture Mapping)</a></li></ul><ul>
<li>
<ul>
<li><a href=#包围盒>包围盒</a></li><li><a href=#aabb加速光线追踪的过程>AABB加速光线追踪的过程</a></li></ul></li></ul><ul>
<li><a href=#辐射度量学>辐射度量学</a>
<ul>
<li><a href=#radiant-intensity>Radiant Intensity</a></li><li><a href=#irradiance>Irradiance</a></li><li><a href=#radiance>Radiance</a></li><li><a href=#brdf>BRDF</a></li><li><a href=#反射方程>反射方程</a></li><li><a href=#渲染方程>渲染方程</a></li></ul></li><li><a href=#蒙特卡洛路径追踪>蒙特卡洛路径追踪</a>
<ul>
<li><a href=#蒙特卡洛积分>蒙特卡洛积分</a></li><li><a href=#路径追踪>路径追踪</a></li></ul></li></ul></nav></aside></header><article class=markdown>
<h1>
<a href=/posts/games101-note/>Games101 笔记</a>
</h1><h5>February 3, 2022</h5><p>之前的内容</p><p>从长宽比和垂直方向的可视角度可以推算出水平方向的可视角度。此外也可推算出正交投影的远近、左右、上下信息。</p><h1 id=光栅化--rasterization>
光栅化 (Rasterization)
<a class=anchor href=#%e5%85%89%e6%a0%85%e5%8c%96--rasterization>#</a>
</h1><h2 id=离散化三角形--triangles>
离散化三角形 (Triangles)
<a class=anchor href=#%e7%a6%bb%e6%95%a3%e5%8c%96%e4%b8%89%e8%a7%92%e5%bd%a2--triangles>#</a>
</h2><ul>
<li>
<p>What is a screen?</p><ul>
<li>An array of pixels</li><li>Size of the array: resolution</li><li>A typical kind of raster display</li></ul></li><li>
<p>Raster == screen in German（屏幕的德语词汇）</p><ul>
<li>Rasterize == drawing onto the screen</li></ul></li><li>
<p>Pixel (FYI, short for “picture element”)</p><ul>
<li>For now: A pixel is a little square with uniform color</li><li>Color is a mixture of (red, green, blue)</li></ul></li></ul><h3 id=光栅化步骤>
光栅化步骤
<a class=anchor href=#%e5%85%89%e6%a0%85%e5%8c%96%e6%ad%a5%e9%aa%a4>#</a>
</h3><ol>
<li>
<p>从变换空间[-1,1]^3^映射到到屏幕空间。首先忽略z方向，使用视口变换将xy空间映射到屏幕。</p><p>视口变换：把[-1,1]^2^变换为[0,width] x [0,height]的屏幕空间。视口变换矩(Viewport transform matrix)阵如下，除以2是因为原空间的宽高都是2，最后一列是平移变换，将原点定义到屏幕中心(否则中心在屏幕左下角)。</p></li></ol><p>$$
<link rel=stylesheet href=/katex/katex.min.css>
<script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>
\[M_{viewprot} =
\begin{bmatrix}
{width \over 2}&0&0&{width \over 2}
\\
0&{height \over 2}&0&{width \over 2}
\\
0&0&1&0
\\
0&0&0&1
\end{bmatrix}\]
</span>
$$</p><ol start=2>
<li>
<p>将3D模型中的三角形片元打散成像素点，以便渲染到屏幕上。</p><p>采样(Sampling)：把一个函数离散化的过程，即将离散的自变量带入函数，获取到离散的值的过程。在光栅化过程中，采样是指用屏幕的像素中心点的位置坐标带入到三角形片元，得到此像素的亮度值和颜色值。</p><p>此步骤的关键是如何判断一个坐标点是否在三角形内部，可以使用叉积判断。假设有三角形ABC和点Q。如果向量AB和向量AQ的叉积大于0，说明Q点在向量AB的左侧（右手定则）。如果BC和BQ，CA和CQ都大于0，说明Q在三角形ABC内部，否则不是。因此Q在三角形ABC内部的充要条件是三个叉积都为正或都为负。</p></li></ol><h2 id=反走样与深度缓冲>
反走样与深度缓冲
<a class=anchor href=#%e5%8f%8d%e8%b5%b0%e6%a0%b7%e4%b8%8e%e6%b7%b1%e5%ba%a6%e7%bc%93%e5%86%b2>#</a>
</h2><p>Antialiasing and Z-Buffering</p><h3 id=走样造成的负面效果>
走样造成的负面效果
<a class=anchor href=#%e8%b5%b0%e6%a0%b7%e9%80%a0%e6%88%90%e7%9a%84%e8%b4%9f%e9%9d%a2%e6%95%88%e6%9e%9c>#</a>
</h3><p>Artifacts due to sampling - “Aliasing”</p><ul>
<li>Jaggies – sampling in space 锯齿</li><li>Moire – undersampling images 摩尔纹</li><li>Wagon wheel effect – sampling in time 车轮效应</li><li>[Many more] …</li></ul><h3 id=反走样的措施>
反走样的措施
<a class=anchor href=#%e5%8f%8d%e8%b5%b0%e6%a0%b7%e7%9a%84%e6%8e%aa%e6%96%bd>#</a>
</h3><ul>
<li>增加采样率 &ndash; Increase sampling rate</li><li>在采样之前先做模糊或滤波处理，可以抗锯齿。从频域角度看，先移除高频信号，然后采样。</li><li>Antialiasing By Supersampling (MSAA) &ndash; 在一个像素内部设置多个采样点，用于计算三角形片元覆盖此像素的百分比。此方法本质上是通过更多的采样点来近似模糊操作。</li></ul><h3 id=模糊处理的方法>
模糊处理的方法
<a class=anchor href=#%e6%a8%a1%e7%b3%8a%e5%a4%84%e7%90%86%e7%9a%84%e6%96%b9%e6%b3%95>#</a>
</h3><p>傅里叶变换可以把一个函数从时域变换为频域。从图像角度看，可以将图像的空间坐标信息视为时域空间，从而通过傅里叶变换成频域信息，之后即可进行滤波操作。对于一般拍摄的图片，低频信号携带的信息远远多于高频信号。此处高频信号指图片上变化非常明显的区域，比如深色和浅色的交界处、人像的边界等。滤波分为：高通滤波(滤除低频信号)，低通滤波(滤除高频信号)，带通滤波(只保留中间某个频率范围的信号)。因此，模糊处理属于低通滤波。</p><p>Filtering = Convolution (= Averaging) &ndash; 滤波 == 卷积 (== 平均)</p><p>卷积定理：时域的卷积 == 频域的乘积，时域的乘积 == 频域的卷积</p><p>如下图所示，每个像素都是周围3x3像素范围内取平均值，最终得到一幅模糊图像，此为卷积操作。卷积定理说明，可以先对图像做傅里叶变换，把时域信息变成频域信息，同时可以对3x3的卷积和做傅里叶变换，之后将两者相乘的结果做逆傅里叶变换，最终得到的图像与对图像做卷积操作得到的模糊图像相同。</p><p><img src=/image-20220204013155320.png alt=image-20220204013155320></p><p>其中，3x3的卷积盒成为box filter，此box越大，则傅里叶变换的频域图面积越小，图像越模糊。反之，box越小，频域图面积越大，图像越清晰。</p><h3 id=从频域角度分析走样产生的原因>
从频域角度分析走样产生的原因
<a class=anchor href=#%e4%bb%8e%e9%a2%91%e5%9f%9f%e8%a7%92%e5%ba%a6%e5%88%86%e6%9e%90%e8%b5%b0%e6%a0%b7%e4%ba%a7%e7%94%9f%e7%9a%84%e5%8e%9f%e5%9b%a0>#</a>
</h3><p>Sampling = Repeating Frequency Contents 采样相当于重复频域的内容。</p><p>如下图所示，a图表示一个时域信号函数，b图是此信号函数经过傅里叶变换得到的频域函数。c图是冲击函数，冲击函数和a图的信号函数相乘得到采样结果(e图)。d图是c图冲击函数经过傅里叶变换后得到的频域上的冲击函数。根据卷积定理：==时域上的乘积相当于频域上的卷积==，b卷积d得到图f。从图中可以看出，时域上离散的采样点变成了频域上重复的频域内容。因此，采样就是在重复原始信号的频谱。</p><p><img src=/image-20220204222301707.png alt=image-20220204222301707></p><p>因此，采样率增大导致原始信号的频谱在频域轴上的间隔变小，频谱发生了混叠，从而产生走样现象。</p><p><img src=/image-20220204223739141.png alt=image-20220204223739141></p><p>通过去除高频信号，可以移除低采样率下混叠部分的频谱信息，从而实现反走样。</p><p><img src=/image-20220204224455294.png alt=image-20220204224455294></p><h3 id=z-buffer>
Z-Buffer
<a class=anchor href=#z-buffer>#</a>
</h3><p>对几何体近似深度排序存在困难，但是对像素进行深度排序很容易。此方法有 frame buffer 和 depth buffer 两套缓冲系统。frame buffer 用于缓冲颜色信息，depth buffer(z-buffer) 用于缓冲深度信息。如果摄像机离物体越近，其z值越小，反之越大。</p><p>初始深度缓冲值设置为无穷大，在光栅化过程中执行如下算法。此算法时间复杂度为 O(n)。</p><pre tabindex=0><code>for (each triangle T)
    for (each sample (x,y,z) in T)
        if (z &lt; zbuffer[x,y]) // closest sample so far
        framebuffer[x,y] = rgb; // update color
        zbuffer[x,y] = z; // update depth
</code></pre><h1 id=着色--shading>
着色 (Shading)
<a class=anchor href=#%e7%9d%80%e8%89%b2--shading>#</a>
</h1><ul>
<li>定义：对不同的物体应用不同材质的过程。</li><li>着色具有局部性，即不考虑阴影。</li></ul><h2 id=blinn-phong-reflectance-model>
Blinn-Phong Reflectance Model
<a class=anchor href=#blinn-phong-reflectance-model>#</a>
</h2><p>分解为漫反射、高光、环境光三项。</p><h3 id=漫反射---diffuse>
漫反射 - Diffuse
<a class=anchor href=#%e6%bc%ab%e5%8f%8d%e5%b0%84---diffuse>#</a>
</h3><p>只考虑光照强度和方向，不考虑观察方向。
$$
L_d = k_d \frac{I}{r^2}{\rm max}(0, \vec n \cdot \vec l)
$$
其中：</p><ul>
<li>L~d~ : diffusely reflected light</li><li>k~d~ : diffuse coefficient (color)</li><li>I/r^2^ : energy arrived at the shading point</li><li>max(0, n · l) : energy received by the shading point</li></ul><h3 id=高光---specular-term>
高光 - Specular Term
<a class=anchor href=#%e9%ab%98%e5%85%89---specular-term>#</a>
</h3><p>$$
半程向量: h = {\rm bisector}(\vec v, \vec l) = \frac {\vec v + \vec l}{||\vec v + \vec l||}
\
L_s = k_s \frac{I}{r^2} {\rm max}(0, {\rm cos} \alpha)^p = k_s \frac{I}{r^2} {\rm max}(0, \vec n \cdot \vec h)^p
$$</p><ul>
<li>半程向量为入射光线与反射光线在观察点处的角平分线所在的向量。</li><li>当且仅当半程向量接近物体表面法线时，反射光线呈现高光态。</li><li>指数p值越大，越接近镜面，表面越光滑。</li></ul><h3 id=环境光---ambient>
环境光 - Ambient
<a class=anchor href=#%e7%8e%af%e5%a2%83%e5%85%89---ambient>#</a>
</h3><p>$$
L_a = k_a + I_a
$$</p><ul>
<li>环境光是常数颜色，与光线和观察角度无关。同时会对所有光源加上同样的平均光照强度。</li><li>保证视口中的所有物体都被光照覆盖，没有黑区。</li></ul><h3 id=最终的blinn-phong反射模型公式>
最终的Blinn-Phong反射模型公式
<a class=anchor href=#%e6%9c%80%e7%bb%88%e7%9a%84blinn-phong%e5%8f%8d%e5%b0%84%e6%a8%a1%e5%9e%8b%e5%85%ac%e5%bc%8f>#</a>
</h3><p>$$
L = L_a + L_d + L_s = k_aI_a + k_d(I/r^2){\rm max}(0, \vec n \cdot \vec l) + k_s(I/r^2){\rm max}(0, \vec n \cdot \vec h)^p
$$</p><h2 id=着色频率--shading-frequencies>
着色频率 (Shading Frequencies)
<a class=anchor href=#%e7%9d%80%e8%89%b2%e9%a2%91%e7%8e%87--shading-frequencies>#</a>
</h2><h3 id=shade-each-triangle-flat-shading>
Shade each triangle (Flat shading)
<a class=anchor href=#shade-each-triangle-flat-shading>#</a>
</h3><h3 id=shade-each-vertex-gouraud-shading>
Shade each vertex (Gouraud shading)
<a class=anchor href=#shade-each-vertex-gouraud-shading>#</a>
</h3><p>计算每个顶点的法线，从而计算出顶点颜色，三角形内部颜色通过顶点间插值得到。</p><h3 id=shade-each-pixel-phong-shading>
Shade each pixel (Phong shading)
<a class=anchor href=#shade-each-pixel-phong-shading>#</a>
</h3><p>计算每个顶点的法线，三角形内部每个像素上的法线通过顶点间的法线插值得到，从而计算出每个像素的颜色。</p><h2 id=图形管线实时渲染>
图形管线(实时渲染)
<a class=anchor href=#%e5%9b%be%e5%bd%a2%e7%ae%a1%e7%ba%bf%e5%ae%9e%e6%97%b6%e6%b8%b2%e6%9f%93>#</a>
</h2><p>Graphics (Real-time Rendering) Pipeline</p><p>用户并不需要对每个fragment分别编写渲染函数，因为渲染函数会被作用在每个fragment上，所以不需要在其中写for循环。</p><h2 id=纹理映射--texture-mapping>
纹理映射 (Texture Mapping)
<a class=anchor href=#%e7%ba%b9%e7%90%86%e6%98%a0%e5%b0%84--texture-mapping>#</a>
</h2><h1 id=光线追踪-ray-tracing>
光线追踪 (Ray Tracing)
<a class=anchor href=#%e5%85%89%e7%ba%bf%e8%bf%bd%e8%b8%aa-ray-tracing>#</a>
</h1><p>光线追踪和光栅化是两种不同的成像方式。之所以需要光线追踪，是因为光栅化在处理全局效果方面表现不好，尤其是光线弹射超过一次的场景。全局效果(Global effects)包括软阴影(Soft shadows)，光面反射(Glossy reflection)，间接光照(Indirect illumination)。</p><p>光栅化是一种很快的、但是很近似的渲染方法，因此图像质量较低。光栅化可以轻松做到实时渲染，实时渲染要求每秒超过30帧。</p><p>光线和三角形片元求交，可以分解为两步：光线和三角形片元所在平面求交；交点是否在三角形片元内部。</p><p>Möller Trumbore Algorithm: 一种快速判定光线和三角形片元是否相交的算法。</p><p>Whitted-Style Ray Tracing：一种光线追踪的实现方式，此外还有路径追踪。</p><h3 id=包围盒>
包围盒
<a class=anchor href=#%e5%8c%85%e5%9b%b4%e7%9b%92>#</a>
</h3><p>Axis-Aligned Bounding Box (AABB) (轴对⻬包围盒)：一种加速光线追踪的技术，其理论是假设空间中存在这样一种包围盒，其三个面和坐标系平行，将几何体完全包裹进来，如果光线不会和包围盒相交，则一定不会和其内部的几何体相交。此方法通过减少不必要的对三角形片元与光线的相交计算，大幅加速光线追踪的计算时间。</p><p>如何判断包围盒与光线是否相交？</p><ul>
<li>光线只在进入包围盒所有的平面才算进入包围盒。光线只在离开任一包围盒的平面就算离开包围盒。</li><li>对每个平面对，计算 t~min~ 和 t~max~ ，可以为负值。</li><li>对包围盒而言，t~enter~ = max{t~min~}, t~exit~ = min{t~max~}。</li><li>从物理规律上看，必然 t~enter~ &lt; t~exit~ ，说明光线会在包围盒内部经过了一段时间，但他们不一定相交。</li><li>如果 t~exit~ &lt; 0，说明包围盒在光线的后面，他们不相交。</li><li>如果 t~exit~ >= 0 且 t~enter~ &lt; 0，说明光源在包围盒内部，他们必然相交。</li><li>光线和包围盒有交点的充要条件是 t~enter~ &lt; t~exit~ && t~exit~ >= 0。</li></ul><h3 id=aabb加速光线追踪的过程>
AABB加速光线追踪的过程
<a class=anchor href=#aabb%e5%8a%a0%e9%80%9f%e5%85%89%e7%ba%bf%e8%bf%bd%e8%b8%aa%e7%9a%84%e8%bf%87%e7%a8%8b>#</a>
</h3><p>两个概念：均匀的格子(Uniform grids)，空间划分(Spatial partitions)。</p><p>均匀的格子(Uniform grids)：</p><ol>
<li>找到一个包围盒，其内部有多个物体</li><li>将这个包围盒划分成一堆格子(grid)</li><li>标记出和物体的表面相交的格子</li><li>计算光线追踪时快速通过没有被标记的格子，对于标记的格子，先判断是否和格子内的物体相交，如果不相交直接通过，否则计算光线和物体的交点（慢）。</li></ol><p>空间划分(Spatial partitions)：</p><p>在物体分布稀疏的地方用大的格子，反之用小的格子，格子大小不一致，其他同 Uniform grids。典型的空间划分算法是 KD-Tree 算法，它是一种基于空间二分切分的算法。KD-Tree 的缺点是很难判断网格和三角形片元是否有交集，以及一个物体有可能出现在多个网格中，因此会被存储多次。</p><p>另一种基于物体的划分(Object Partitions)是Bounding Volume Hierarchy (BVH)，它也是一种空间划分算法。由于避免了 KD-Tree 的那两个缺陷，成为了目前广泛使用的划分算法。</p><p>BVH的步骤：</p><ul>
<li>首先找到一个包围盒。</li><li>递归地把其内部的几何体(三角形片元)分为两个子部分，重新计算两个子部分的包围盒。</li><li>直到每个包围盒内部的三角形片元数量足够少时，停止递归。</li><li>将实际的Object记录在叶子节点里，其他部分做加速判断。</li></ul><p>BVH的划分方法：</p><ul>
<li>选择一个维度去划分 (类似于KD-Tree)。</li><li>总是选择节点中轴线最长的那个轴去划分。</li><li>对每个Object进行编号，取中间的那个编号的Object进行划分，可保证平衡划分。中间编号可以使用==快速选择算法==在O(n)时间找到。</li></ul><p>BVH伪代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Intersect(Ray ray, BVH node) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ray misses node.bbox) <span style=color:#66d9ef>return</span>; <span style=color:#75715e>// 光线和BVH节点不相交，直接return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (node is a leaf node)  <span style=color:#75715e>// 叶子节点，光线和其内部所有物体求交，返回最先相交的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        test intersection with all objs;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> closest intersection;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 中间节点，递归，返回最先相交的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    hit1 <span style=color:#f92672>=</span> Intersect(ray, node.child1);
</span></span><span style=display:flex><span>    hit2 <span style=color:#f92672>=</span> Intersect(ray, node.child2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> the closer of hit1, hit2;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=路径追踪--path-tracing>
路径追踪 (Path Tracing)
<a class=anchor href=#%e8%b7%af%e5%be%84%e8%bf%bd%e8%b8%aa--path-tracing>#</a>
</h1><h2 id=辐射度量学>
辐射度量学
<a class=anchor href=#%e8%be%90%e5%b0%84%e5%ba%a6%e9%87%8f%e5%ad%a6>#</a>
</h2><p>Basic radiometry</p><p>上述提到的方法均属于 Whitted-Style 光线追踪，由于此方法的光照强度等物理量没有被精确定义，导致最终的结果不真实。辐射度量学用于精确定义与光照相关的物理量，包括精确描述光与物体表面如何作用，精确描述光源、材质、光线的传播方法等物理量。</p><h3 id=radiant-intensity>
Radiant Intensity
<a class=anchor href=#radiant-intensity>#</a>
</h3><p>Definition: The radiant (luminous) intensity is the power per unit solid angle (⽴体⻆) emitted by a point light source. 光源在单位立体角上辐射的能量。</p><p>推导过程如下，其中r为到原点的距离，θ为立体角矢量与z轴正向的夹角，Φ为立体角矢量在x-y平面的投影与x轴的夹角。r∈[0,+∞)，θ∈[0, π]， φ∈[0,2π]。
$$
球坐标中单位球面的定义\quad {\rm d} A = (r {\rm d}θ)(r {\rm sin}θ {\rm d}Φ) = r^2 {\rm sin}θ , {\rm d}θ {\rm d}Φ
\
球坐标中立体角的定义\quad {\rm d}ω = {{\rm d}A \over r^2} = {\rm sin}θ , {\rm d}θ {\rm d}Φ
\\
立体角在整个球面的积分为4π
\
球面积分\quad Ω = \int_{S^2}{\rm d}ω = \int_{0}^{2π}\int_{0}^{π}{\rm sin}θ , {\rm d}θ {\rm d}Φ = 4π
\\
假设点光源在各个方向辐射的能量相同，则点光源的整体功率为:
\
Φ = \int_{S^2} I , {\rm d}ω = 4πI
\\
因此，Radiant \ Intensity为:
\
I = {Φ \over 4π}
$$
由上述推到可看出 Radiant Intensity 和到光源的距离无关。立体角的物理意义是在球面空间的某个方向上张开多大的角度。</p><p>立体角 sinθdθdΦ 不光与 dθdΦ 有关，还与 sinθ 有关，说明立体角在球坐标空间中对球面的划分并不平衡，在赤道区域大，在两极区域小。</p><h3 id=irradiance>
Irradiance
<a class=anchor href=#irradiance>#</a>
</h3><p>Definition: The irradiance is the power per (perpendicular/projected) unit area incident on a surface point. 各个方向的光线投影到物体单位表面上的功率。注意这里是投影能量，需要乘以cosθ。
$$
E(x) \equiv {{{\rm d}Φ(x)} \over {\rm d}A}
$$
在距离一个点光源某个固定半径的球面上的 Irradiance 如下所示，其中 E 为 Irradiance, I 为 Radiant Intensity
$$
E = {Φ \over 4πr^2} = {I \over r^2}
$$
由上式可以看出 Irradiance 随着半径增大而衰减。</p><h3 id=radiance>
Radiance
<a class=anchor href=#radiance>#</a>
</h3><p>Definition: The radiance (luminance) is the power emitted, reflected, transmitted or received by a surface, per unit solid angle, per projected unit area. 光线传播过程中，在路径中的某个物体的单位表面上沿着某个立体角方向发射的能量。
$$
L(p,\omega) \equiv {{\rm d}^2\Phi(p,\omega) \over {\rm d}\omega {\rm d}A{\rm cos}\theta} \quad \text{(cosθ用于计算投影表面积)}
$$</p><ul>
<li>Recall
<ul>
<li>Irradiance: power per projected unit area</li><li>Intensity: power per solid angle</li></ul></li><li>So
<ul>
<li>Radiance: Irradiance per solid angle. 物体单位表面积在某个立体角方向上接收到的能量。</li><li>Radiance: Intensity per projected unit area.</li></ul></li></ul><p>Radiance 与 Irradiance 的区别在于后者度量物体的单位表面积在所有方向上接收到的能量，而前者只度量某个方向上接收到的能量。</p><h3 id=brdf>
BRDF
<a class=anchor href=#brdf>#</a>
</h3><p>Bidirectional Reflectance Distribution Function (BRDF) 双向反射分布函数</p><p>The Bidirectional Reflectance Distribution Function (BRDF) represents how much light is reflected into each outgoing direction from each incoming direction.</p><h3 id=反射方程>
反射方程
<a class=anchor href=#%e5%8f%8d%e5%b0%84%e6%96%b9%e7%a8%8b>#</a>
</h3><p>The Reflection Equation</p><p>观察被照射物体表面上一个单位面积，以及从此单位表面积到照相机的矢量。假设此表面积吸收了全部入射光照能量，然后向各个方向发射这些能量。考察这个单位面积上，所有入射光线在这个矢量方向上的反射光照强度贡献。</p><p><img src=/image-20220212223506432.png alt=image-20220212223506432></p><h3 id=渲染方程>
渲染方程
<a class=anchor href=#%e6%b8%b2%e6%9f%93%e6%96%b9%e7%a8%8b>#</a>
</h3><p>Recursive Equation
$$
L_r(x, \omega_r) = L_e(x, \omega_r) + \int_{\Omega} L_r(x&rsquo;, -\omega_i)f(x,\omega_i,\omega_r),{\rm cos}\theta_i,{\rm d}\omega_i
$$</p><p>全局光照：直接光照 + 间接光照</p><h2 id=蒙特卡洛路径追踪>
蒙特卡洛路径追踪
<a class=anchor href=#%e8%92%99%e7%89%b9%e5%8d%a1%e6%b4%9b%e8%b7%af%e5%be%84%e8%bf%bd%e8%b8%aa>#</a>
</h2><p>Monte Carlo Path Tracing</p><h3 id=蒙特卡洛积分>
蒙特卡洛积分
<a class=anchor href=#%e8%92%99%e7%89%b9%e5%8d%a1%e6%b4%9b%e7%a7%af%e5%88%86>#</a>
</h3><p>Monte Carlo Integration
$$
\int f(x) {\rm d}x = {1 \over N} \sum_{i=1}^N \frac{f(X_i)}{p(X_i)} \quad X_i \sim p(x)
$$
其中 f(x)是原函数，p(x)是概率密度函数。N越大(样本量越大)结果越准。不需要考虑积分域，因为概率密度函数隐含了此信息。</p><h3 id=路径追踪>
路径追踪
<a class=anchor href=#%e8%b7%af%e5%be%84%e8%bf%bd%e8%b8%aa>#</a>
</h3><p>Path Tracing</p><p>一般光线每次弹射后会有无数方向，如果每根弹射光线都要进行计算，则要被计算的光线将会呈指数级增长，导致计算过程中出现路径爆炸的问题，造成计算耗时无限延长。</p><p>由于#rays = N^#bounces^，当N=1时不会引发路径爆炸。此时，在对任何一点进行着色时，随机往一个方向采样一个ω~i~进行渲染方程(PDF)的计算。因此，用N=1进行蒙特卡洛积分的方法被称作==路径追踪==。</p><p>一般N=1时的蒙特卡洛积分噪声会很大，这可以通过在一个像素点上追踪多根光线解决。只需在每个像素上追踪更多的路径，并计算他们的亮度平均值。</p><p><img src=/image-20220219123709819.png alt=image-20220219123709819></p><p>后续的问题</p><ul>
<li>用于终止路径追踪递归函数的俄罗斯轮盘赌算法</li><li>用于减少无效路径追踪的光源采样法</li><li>光源采样法的判断直接光照是否被阻挡算法</li><li>对于路径追踪，点光源难以处理，一般简化为面积相对小的面光源</li></ul></article><footer class=book-footer>
<div class="flex flex-wrap justify-between">
</div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>
</footer><div class=book-comments>
</div><label for=menu-control class="hidden book-menu-overlay"></label>
</div><aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#离散化三角形--triangles>离散化三角形 (Triangles)</a>
<ul>
<li><a href=#光栅化步骤>光栅化步骤</a></li></ul></li><li><a href=#反走样与深度缓冲>反走样与深度缓冲</a>
<ul>
<li><a href=#走样造成的负面效果>走样造成的负面效果</a></li><li><a href=#反走样的措施>反走样的措施</a></li><li><a href=#模糊处理的方法>模糊处理的方法</a></li><li><a href=#从频域角度分析走样产生的原因>从频域角度分析走样产生的原因</a></li><li><a href=#z-buffer>Z-Buffer</a></li></ul></li></ul><ul>
<li><a href=#blinn-phong-reflectance-model>Blinn-Phong Reflectance Model</a>
<ul>
<li><a href=#漫反射---diffuse>漫反射 - Diffuse</a></li><li><a href=#高光---specular-term>高光 - Specular Term</a></li><li><a href=#环境光---ambient>环境光 - Ambient</a></li><li><a href=#最终的blinn-phong反射模型公式>最终的Blinn-Phong反射模型公式</a></li></ul></li><li><a href=#着色频率--shading-frequencies>着色频率 (Shading Frequencies)</a>
<ul>
<li><a href=#shade-each-triangle-flat-shading>Shade each triangle (Flat shading)</a></li><li><a href=#shade-each-vertex-gouraud-shading>Shade each vertex (Gouraud shading)</a></li><li><a href=#shade-each-pixel-phong-shading>Shade each pixel (Phong shading)</a></li></ul></li><li><a href=#图形管线实时渲染>图形管线(实时渲染)</a></li><li><a href=#纹理映射--texture-mapping>纹理映射 (Texture Mapping)</a></li></ul><ul>
<li>
<ul>
<li><a href=#包围盒>包围盒</a></li><li><a href=#aabb加速光线追踪的过程>AABB加速光线追踪的过程</a></li></ul></li></ul><ul>
<li><a href=#辐射度量学>辐射度量学</a>
<ul>
<li><a href=#radiant-intensity>Radiant Intensity</a></li><li><a href=#irradiance>Irradiance</a></li><li><a href=#radiance>Radiance</a></li><li><a href=#brdf>BRDF</a></li><li><a href=#反射方程>反射方程</a></li><li><a href=#渲染方程>渲染方程</a></li></ul></li><li><a href=#蒙特卡洛路径追踪>蒙特卡洛路径追踪</a>
<ul>
<li><a href=#蒙特卡洛积分>蒙特卡洛积分</a></li><li><a href=#路径追踪>路径追踪</a></li></ul></li></ul></nav></div></aside></main></body></html>