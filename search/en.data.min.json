[{"id":0,"href":"/","title":"Notes","parent":"","content":""},{"id":1,"href":"/database/sql/","title":"SQL教程","parent":"数据库","content":" 聚合函数（Aggregate Functions） SELECT MAX(invoice_total) as max, MIN(invoice_total) as min, AVG(invoice_total) as avg, SUM(invoice_total) as total_sales FROM invoices; SELECT COUNT(payment_date) AS no_of_paid, -- 注意count不统计null值 COUNT(*) AS no_of_invoices -- 统计全部值 FROM invoices; SELECT \u0026#39;Q1 2019\u0026#39; AS data_range, SUM(invoice_total) AS total_sales, SUM(payment_total) AS total_payments, SUM(invoice_total - payment_total) AS unpaid FROM invoices WHERE invoice_date BETWEEN \u0026#39;2019-01-01\u0026#39; AND \u0026#39;2019-03-31\u0026#39; UNION SELECT \u0026#39;Q2 2019\u0026#39; AS data_range, SUM(invoice_total) AS total_sales, SUM(payment_total) AS total_payments, SUM(invoice_total - payment_total) AS unpaid FROM invoices WHERE invoice_date BETWEEN \u0026#39;2019-04-01\u0026#39; AND \u0026#39;2019-06-30\u0026#39; UNION SELECT \u0026#39;Total\u0026#39; AS data_range, SUM(invoice_total) AS total_sales, SUM(payment_total) AS total_payments, SUM(invoice_total - payment_total) AS unpaid FROM invoices WHERE invoice_date BETWEEN \u0026#39;2019-01-01\u0026#39; AND \u0026#39;2019-06-30\u0026#39;; data_range total_sales total_payments unpaid Q1 2019 699.95 323 43 Q2 2019 32 23 34 Q3 2019 34 3 22 Q4 2019 55 32 1 Q1 2019 97 32 2 Total 357 875 785 分组查询 SELECT state, city SUM(invoice_total) AS total_sales FROM invoices i JOIN clients USING (client_id) -- 相当于 clients.client_id = invoices.client_id WHERE invoice_date \u0026lt;= \u0026#39;2019-7-01\u0026#39; GROUP BY state, city ORDER BY total_sales DESC; SELECT date, pm.name AS payment_method, SUM(amount) AS total_payments FROM payments p JOIN payment_methods pm ON p.payment_method = pm.payment_method_id GROUP BY date, payment_method ORDER BY date; HAVING 语句 允许在 GROUP BY 语句后执行过滤\nSELECT date, pm.name AS payment_method, SUM(amount) AS total_payments FROM payments p JOIN payment_methods pm ON p.payment_method = pm.payment_method_id GROUP BY date, payment_method HAVING total_payments \u0026gt; 500 AND no_of_invoices \u0026gt; 5 ORDER BY date; SELECT c.customer_id, c.first_name, c.last_name, SUM(oi.quantity * oi.unit_price) AS total_spent FROM customers c JOIN orders o USING (customer_id) JOIN order_items oi USING (order_id) WHERE city = \u0026#39;Atlanta\u0026#39; GROUP BY c.customer_id, c.first_name, c.last_name HAVING total_spent \u0026gt; 100; String Functions SELECT LENGTH(\u0026#39;MsSQL\u0026#39;); -- 5 SELECT UPPER(\u0026#39;google\u0026#39;); -- GOOGLE SELECT LOWER(\u0026#39;GOOGLE\u0026#39;); -- google SELECT TRIM(\u0026#39; banana \u0026#39;); -- banana SELECT LTRIM(\u0026#39; banana \u0026#39;); -- banana SELECT RTRIM(\u0026#39; banana \u0026#39;); -- banana SELECT LEFT(\u0026#39;congratulations\u0026#39;, 4); -- cong SELECT RIGHT(\u0026#39;congratulations\u0026#39;, 4); -- ions SELECT SPACE(6); -- 生成6个空格 SELECT REVERSE(\u0026#39;abce\u0026#39;); -- dcba SELECT REPEAT(\u0026#39;*\u0026#39;, 4); -- **** SELECT CONCAT(\u0026#39;abc\u0026#39;, \u0026#39;def\u0026#39;, \u0026#39;ghi\u0026#39;); -- abcdefghi 强制连接 SELECT CONCAT(\u0026#39;abc\u0026#39;, NULL, \u0026#39;def\u0026#39;, \u0026#39;ghi\u0026#39;); -- NULL SELECT CONCAT(14.3) -- 字符串的14.3 Mathematical Functions ABS, CEILING, FLOOR, LOG, LOG10, POW, ROUND(四舍五入), TRUNCATE(截断), RAND(0-1 之间随机数)\nSELECT ROUND(-1.24); -- -1 SELECT ROUND(-1.65); -- -2 SELECT ROUND(-1.23456, 2); -- -1.23 SELECT ROUND(2.2873, 2); -- 2.29 SELECT TRUNCATE(2.2878, 3); -- 2.287 SELECT TRUNCATE(122, -1); -- 120 DateTime Functions (过) NOW, CURDATE, CURTIME, YEAR(NOW()), MONTH(NOW()), DAY(NOW()), HOUR(NOW()), DAYNAME(\u0026lsquo;2020-01-31\u0026rsquo;)(获取星期)\nSELECT EXTRACT(YEAR_MONTH FROM \u0026#39;2020-01-31 05:06:07\u0026#39;); -- 202001 SELECT * FROM orders WHERE YEAR(order_date) \u0026gt;= YEAR(NOW()); IF 条件语句 SELECT order_id, IFNULL(shipper_id, \u0026#39;Not Assigned\u0026#39;) AS shipper FROM orders; SELECT order_id, COALESCE(shipper_id, comments, \u0026#39;Not Assigned\u0026#39;) AS shipper -- 依次查找shipper_id, comments, 找到就停止, 否则设置为 \u0026#39;Not Assigned\u0026#39; FROM orders; -- IF ## IF(condition, value_if_true, value_if_false) SELECT order_id, order_date, IF(YEAR(order_date) = \u0026#39;2019\u0026#39;, \u0026#39;Active\u0026#39;, \u0026#39;Archived\u0026#39;) AS category FROM orders; SELECT product_id, name, COUNT(*) as orders, IF(COUNT(*) \u0026gt; 1, \u0026#39;More Than Once\u0026#39;, \u0026#39;Once\u0026#39;) AS Frequency FROM products JOIN order_items USING(product_id) GROUP BY product_id, name; CASE 条件语句 SELECT order_id, order_date, CASE WHEN YEAR(order_date) = YEAR(NOW()) THEN \u0026#39;this year\u0026#39; WHEN YEAR(order_date) = YEAR(NOW()) - 1 THEN \u0026#39;last year\u0026#39; WHEN YEAR(order_date) = YEAR(NOW()) - 2 THEN \u0026#39;two years ago\u0026#39; ELSE \u0026#39;long long ago\u0026#39; END AS category FROM orders; SELECT CONCAT(first_name, \u0026#39; \u0026#39;, last_name) AS customer, points, CASE WHEN points \u0026gt; 3000 THEN \u0026#39;Gold\u0026#39; WHEN points \u0026gt;= 2000 THEN \u0026#39;Silver\u0026#39; ELSE \u0026#39;Bronze\u0026#39; END AS category FROM customers; Subquery 子查询 SELECT * FROM student WHERE height \u0026gt; (SELECT AVG(height) FROM student); IN / NOT IN SELECT * FROM products WHERE product_id NOT IN (SELECT product_id FROM order_items); -- 查询所有不在order_items表中的product SELECT * FROM products LEFT JOIN order_items USING (product_id) WHERE invoice_id IS NULL; -- 与上面结论相同的JOIN写法 ALL / ANY SELECT * FROM invoices WHERE invoice_total \u0026gt; ALL(SELECT invoice_total FROM invoices WHERE client_id = 3); -- 主句中的 invoice_total 大于子句中所有的 SELECT * FROM invoices WHERE invoice_total \u0026gt; (SELECT MAX(invoice_total) FROM invoices WHERE client_id = 3); -- 与上句等价 此外，IN 和 ANY 也是等价的\n"},{"id":2,"href":"/database/","title":"数据库","parent":"Notes","content":" 数据库\n"},{"id":3,"href":"/database/injection-attack/","title":"注入攻击","parent":"数据库","content":" 识别漏洞 如下请求如果结果相同，说明很可能存在 SQL 注入漏洞\nhttp://www.victim.com/showproducts.php?category=bikes # 原始请求 http://www.victim.com/showproducts.php?category=bi\u0026#39;||\u0026#39;kes # Oracle 和 PostgreSQL http://www.victim.com/showproducts.php?category=bi\u0026#39;+\u0026#39;kes # MS SQLServer http://www.victim.com/showproducts.php?category=bi\u0026#39; \u0026#39;kes # MySQL "},{"id":4,"href":"/computer-graphics/games101/","title":"GAMES 101","parent":"计算机图形学","content":"之前的内容\n从长宽比和垂直方向的可视角度可以推算出水平方向的可视角度。此外也可推算出正交投影的远近、左右、上下信息。\n光栅化 (Rasterization) 离散化三角形 (Triangles) What is a screen?\nAn array of pixels Size of the array: resolution A typical kind of raster display Raster == screen in German（屏幕的德语词汇）\nRasterize == drawing onto the screen Pixel (FYI, short for “picture element”)\nFor now: A pixel is a little square with uniform color Color is a mixture of (red, green, blue) 光栅化步骤 从变换空间[-1,1]^3^映射到到屏幕空间。首先忽略 z 方向，使用视口变换将 xy 空间映射到屏幕。\n视口变换：把[-1,1]^2^变换为[0,width] x [0,height]的屏幕空间。视口变换矩(Viewport transform matrix)阵如下，除以 2 是因为原空间的宽高都是 2，最后一列是平移变换，将原点定义到屏幕中心(否则中心在屏幕左下角)。\n$$ M_{viewprot} = \\begin{bmatrix} {width \\over 2}\u0026amp;0\u0026amp;0\u0026amp;{width \\over 2} \\ 0\u0026amp;{height \\over 2}\u0026amp;0\u0026amp;{width \\over 2} \\ 0\u0026amp;0\u0026amp;1\u0026amp;0 \\ 0\u0026amp;0\u0026amp;0\u0026amp;1 \\end{bmatrix} $$\n将 3D 模型中的三角形片元打散成像素点，以便渲染到屏幕上。\n采样(Sampling)：把一个函数离散化的过程，即将离散的自变量带入函数，获取到离散的值的过程。在光栅化过程中，采样是指用屏幕的像素中心点的位置坐标带入到三角形片元，得到此像素的亮度值和颜色值。\n此步骤的关键是如何判断一个坐标点是否在三角形内部，可以使用叉积判断。假设有三角形 ABC 和点 Q。如果向量 AB 和向量 AQ 的叉积大于 0，说明 Q 点在向量 AB 的左侧（右手定则）。如果 BC 和 BQ，CA 和 CQ 都大于 0，说明 Q 在三角形 ABC 内部，否则不是。因此 Q 在三角形 ABC 内部的充要条件是三个叉积都为正或都为负。\n反走样与深度缓冲 Antialiasing and Z-Buffering\n走样造成的负面效果 Artifacts due to sampling - “Aliasing”\nJaggies – sampling in space 锯齿 Moire – undersampling images 摩尔纹 Wagon wheel effect – sampling in time 车轮效应 [Many more] … 反走样的措施 增加采样率 \u0026ndash; Increase sampling rate 在采样之前先做模糊或滤波处理，可以抗锯齿。从频域角度看，先移除高频信号，然后采样。 Antialiasing By Supersampling (MSAA) \u0026ndash; 在一个像素内部设置多个采样点，用于计算三角形片元覆盖此像素的百分比。此方法本质上是通过更多的采样点来近似模糊操作。 模糊处理的方法 傅里叶变换可以把一个函数从时域变换为频域。从图像角度看，可以将图像的空间坐标信息视为时域空间，从而通过傅里叶变换成频域信息，之后即可进行滤波操作。对于一般拍摄的图片，低频信号携带的信息远远多于高频信号。此处高频信号指图片上变化非常明显的区域，比如深色和浅色的交界处、人像的边界等。滤波分为：高通滤波(滤除低频信号)，低通滤波(滤除高频信号)，带通滤波(只保留中间某个频率范围的信号)。因此，模糊处理属于低通滤波。\nFiltering = Convolution (= Averaging) \u0026ndash; 滤波 == 卷积 (== 平均)\n卷积定理：时域的卷积 == 频域的乘积，时域的乘积 == 频域的卷积\n如下图所示，每个像素都是周围 3x3 像素范围内取平均值，最终得到一幅模糊图像，此为卷积操作。卷积定理说明，可以先对图像做傅里叶变换，把时域信息变成频域信息，同时可以对 3x3 的卷积和做傅里叶变换，之后将两者相乘的结果做逆傅里叶变换，最终得到的图像与对图像做卷积操作得到的模糊图像相同。\n其中，3x3 的卷积盒成为 box filter，此 box 越大，则傅里叶变换的频域图面积越小，图像越模糊。反之，box 越小，频域图面积越大，图像越清晰。\n从频域角度分析走样产生的原因 Sampling = Repeating Frequency Contents 采样相当于重复频域的内容。\n如下图所示，a 图表示一个时域信号函数，b 图是此信号函数经过傅里叶变换得到的频域函数。c 图是冲击函数，冲击函数和 a 图的信号函数相乘得到采样结果(e 图)。d 图是 c 图冲击函数经过傅里叶变换后得到的频域上的冲击函数。根据卷积定理：==时域上的乘积相当于频域上的卷积==，b 卷积 d 得到图 f。从图中可以看出，时域上离散的采样点变成了频域上重复的频域内容。因此，采样就是在重复原始信号的频谱。\n因此，采样率增大导致原始信号的频谱在频域轴上的间隔变小，频谱发生了混叠，从而产生走样现象。\n通过去除高频信号，可以移除低采样率下混叠部分的频谱信息，从而实现反走样。\nZ-Buffer 对几何体近似深度排序存在困难，但是对像素进行深度排序很容易。此方法有 frame buffer 和 depth buffer 两套缓冲系统。frame buffer 用于缓冲颜色信息，depth buffer(z-buffer) 用于缓冲深度信息。如果摄像机离物体越近，其 z 值越小，反之越大。\n初始深度缓冲值设置为无穷大，在光栅化过程中执行如下算法。此算法时间复杂度为 O(n)。\nfor (each triangle T) for (each sample (x,y,z) in T) if (z \u0026lt; zbuffer[x,y]) // closest sample so far framebuffer[x,y] = rgb; // update color zbuffer[x,y] = z; // update depth 着色 (Shading) 定义：对不同的物体应用不同材质的过程。 着色具有局部性，即不考虑阴影。 Blinn-Phong Reflectance Model 分解为漫反射、高光、环境光三项。\n漫反射 - Diffuse 只考虑光照强度和方向，不考虑观察方向。\n$$ L_d = k_d \\frac{I}{r^2}{\\rm max}(0, \\vec n \\cdot \\vec l) $$\n其中：\nL~d~ : diffusely reflected light k~d~ : diffuse coefficient (color) I/r^2^ : energy arrived at the shading point max(0, n · l) : energy received by the shading point 高光 - Specular Term $$ 半程向量: h = {\\rm bisector}(\\vec v, \\vec l) = \\frac {\\vec v + \\vec l}{||\\vec v + \\vec l||} \\ L_s = k_s \\frac{I}{r^2} {\\rm max}(0, {\\rm cos} \\alpha)^p = k_s \\frac{I}{r^2} {\\rm max}(0, \\vec n \\cdot \\vec h)^p $$\n半程向量为入射光线与反射光线在观察点处的角平分线所在的向量。 当且仅当半程向量接近物体表面法线时，反射光线呈现高光态。 指数 p 值越大，越接近镜面，表面越光滑。 环境光 - Ambient $$ L_a = k_a + I_a $$\n环境光是常数颜色，与光线和观察角度无关。同时会对所有光源加上同样的平均光照强度。 保证视口中的所有物体都被光照覆盖，没有黑区。 最终的 Blinn-Phong 反射模型公式 $$ L = L_a + L_d + L_s = k_aI_a + k_d(I/r^2){\\rm max}(0, \\vec n \\cdot \\vec l) + k_s(I/r^2){\\rm max}(0, \\vec n \\cdot \\vec h)^p $$\n着色频率 (Shading Frequencies) Shade each triangle (Flat shading) 对每个三角形片元计算颜色，同一个三角形片元内部的像素具有相同的值。\nShade each vertex (Gouraud shading) 计算每个顶点的法线，从而计算出顶点颜色，三角形内部颜色通过顶点间插值得到。\nShade each pixel (Phong shading) 计算每个顶点的法线，三角形内部每个像素上的法线通过顶点间的法线插值得到，从而计算出每个像素的颜色。\n图形管线(实时渲染) Graphics (Real-time Rendering) Pipeline\n用户并不需要对每个 fragment 分别编写渲染函数，因为渲染函数会被作用在每个 fragment 上，所以不需要在其中写 for 循环。\n三角形内插值: 重心坐标 Interpolation Across Triangles: Barycentric Coordinates\n为什么要插值？\n已知三角形顶点的各种量，需要在三角形内部平滑过渡。 哪些量需要插值？\nTexture coordinates, colors, normal vectors (Phong shading), \u0026hellip; 重心坐标定义 三角形内任一点(x, y)都可以表示为三角形顶点 A, B, C 的坐标的线性组合。\n$$ (x, y) = \\alpha A + \\beta B + \\gamma C $$\n上式中 α、β、γ 为线性组合系数，即为==重心坐标==，需满足如下条件\n$$ \\alpha + \\beta + \\gamma = 1 \\quad \\text{(保证点在三角形所在平面上)} \\ \\alpha ,, \\beta ,,\\gamma \u0026gt; 0 \\quad \\text{(保证点在三角形内部)} $$\n如何计算：\n重心坐标是连接(x,y)点与三角形三个顶点，将三角形分成三个子三角形，计算每个子三角形的面积所占父三角形面积的比例。也可按照下式计算。\n纹理映射 (Texture Mapping) 共用一套着色模型的三维物体表面的不同位置，定义不同的属性（漫反射系数等），从而达到纹理映射的目的。\n简单纹理映射： 漫反射颜色 (Deffuse Color) 对每个光栅化屏幕采样点(x,y)（一般是像素中心），计算(x,y)点的纹理坐标(u,v)（使用重心坐标） 之后根据(u,v)在纹理图上采样，得到颜色值 将上一步获得的颜色值，通过漫反射系数的方式，设置在每个采样点上。 如果纹理图的面积远小于要映射到的物体的表面积，会造成纹理被放大，从而出现锯齿。这种问题的深层原因是像素在纹理上采样，由于纹理图较小，造成采样点映射到纹理图的对应点的坐标是一些非整数的值（一般只有整数值才能对应到纹理图上的一个像素）。如果单纯采用四舍五入取整数来对纹理图进行采样，会造成多个屏幕像素采样到相同的纹理像素上，从而产生锯齿。这种情况下需要在纹理图上对这些非整数的点进行双线性插值，从而在实际渲染中得到模糊效果。此外也可用 Bicubic 进行三次插值，以得到更好的结果。\n如果纹理图的面积过大，更多远处的纹理像素点会被屏幕像素点覆盖，导致对纹理图的采样过于稀疏，产生摩尔纹。超采样（用更密集的采样点进行采样）会解决这种问题，但会导致计算量增大。由于这种现象是由于采样造成的，而采样是一种 Point Query，可以通过使用范围查询（Range Query）方法代替采样方法，之后再光栅化，则可以解决此问题。范围查询即通过对屏幕像素覆盖的多个纹理像素取平均值，作为屏幕像素的值。\nMipmap，一种对纹理像素取平均值的方法。Allowing (fast, approx., square) range queries.\nMipmap 会产生 Overblur，导致远处的纹理过于模糊。可通过各向异性过滤（Anisotropic Filtering）部分解决问题。此外还有 EWA 过滤。各向异性过滤只会增加显存开销，不会显著增加计算量。\n纹理的高级应用 环境光照 (Environment Map)\n又称环境贴图，用纹理描述环境光，贴在物体表面，产生更为逼真的反射效果。\n凹凸贴图 (Bump Mapping)\n纹理不止可以定义物体表面不同位置的颜色，还可以定义其他属性，比如定义表面上一点相对于所在表面的相对高度。此时会在不改变几何形体的情况下改变各个三角形片元的法线方向，从而在着色过程中产生凹凸不平的效果。\n位移贴图 (Displacement Mapping)\n由于凹凸贴图在物体边缘和阴影上不起作用，从而造成失真，位移贴图会根据纹理信息对三角形顶点做真实的位置移动，从而解决此问题。此方法要求三角形足够细密，从而使模型变化足以匹配纹理的变化，但这会使得采样率变高，导致计算量增加。\nDirectX 的动态曲面细分(Dynamic Tessellation)功能可以让三角形密度按需匹配纹理，OpenGL 无此功能。\n三维纹理\n借助三维空间中的噪声函数动态计算空间中的纹理，使纹理可以覆盖到物体内部。可用于体渲染。\n几何 (Geometry) 38'46\u0026quot;\n光线追踪 (Ray Tracing) 光线追踪和光栅化是两种不同的成像方式。之所以需要光线追踪，是因为光栅化在处理全局效果方面表现不好，尤其是光线弹射超过一次的场景。全局效果(Global effects)包括软阴影(Soft shadows)，光面反射(Glossy reflection)，间接光照(Indirect illumination)。\n光栅化是一种很快的、但是很近似的渲染方法，因此图像质量较低。光栅化可以轻松做到实时渲染，实时渲染要求每秒超过 30 帧。\n光线和三角形片元求交，可以分解为两步：光线和三角形片元所在平面求交；交点是否在三角形片元内部。\nMöller Trumbore Algorithm: 一种快速判定光线和三角形片元是否相交的算法。\nWhitted-Style Ray Tracing：一种光线追踪的实现方式，此外还有路径追踪。\n包围盒 Axis-Aligned Bounding Box (AABB) (轴对⻬包围盒)：一种加速光线追踪的技术，其理论是假设空间中存在这样一种包围盒，其三个面和坐标系平行，将几何体完全包裹进来，如果光线不会和包围盒相交，则一定不会和其内部的几何体相交。此方法通过减少不必要的对三角形片元与光线的相交计算，大幅加速光线追踪的计算时间。\n如何判断包围盒与光线是否相交？\n光线只在进入包围盒所有的平面才算进入包围盒。光线只在离开任一包围盒的平面就算离开包围盒。 对每个平面对，计算 t~min~ 和 t~max~ ，可以为负值。 对包围盒而言，t~enter~ = max{t~min~}, t~exit~ = min{t~max~}。 从物理规律上看，必然 t~enter~ \u0026lt; t~exit~ ，说明光线会在包围盒内部经过了一段时间，但他们不一定相交。 如果 t~exit~ \u0026lt; 0，说明包围盒在光线的后面，他们不相交。 如果 t~exit~ \u0026gt;= 0 且 t~enter~ \u0026lt; 0，说明光源在包围盒内部，他们必然相交。 光线和包围盒有交点的充要条件是 t~enter~ \u0026lt; t~exit~ \u0026amp;\u0026amp; t~exit~ \u0026gt;= 0。 AABB 加速光线追踪的过程 两个概念：均匀的格子(Uniform grids)，空间划分(Spatial partitions)。\n均匀的格子(Uniform grids)：\n找到一个包围盒，其内部有多个物体 将这个包围盒划分成一堆格子(grid) 标记出和物体的表面相交的格子 计算光线追踪时快速通过没有被标记的格子，对于标记的格子，先判断是否和格子内的物体相交，如果不相交直接通过，否则计算光线和物体的交点（慢）。 空间划分(Spatial partitions)：\n在物体分布稀疏的地方用大的格子，反之用小的格子，格子大小不一致，其他同 Uniform grids。典型的空间划分算法是 KD-Tree 算法，它是一种基于空间二分切分的算法。KD-Tree 的缺点是很难判断网格和三角形片元是否有交集，以及一个物体有可能出现在多个网格中，因此会被存储多次。\n另一种基于物体的划分(Object Partitions)是 Bounding Volume Hierarchy (BVH)，它也是一种空间划分算法。由于避免了 KD-Tree 的那两个缺陷，成为了目前广泛使用的划分算法。\nBVH 的步骤：\n首先找到一个包围盒。 递归地把其内部的几何体(三角形片元)分为两个子部分，重新计算两个子部分的包围盒。 直到每个包围盒内部的三角形片元数量足够少时，停止递归。 将实际的 Object 记录在叶子节点里，其他部分做加速判断。 BVH 的划分方法：\n选择一个维度去划分 (类似于 KD-Tree)。 总是选择节点中轴线最长的那个轴去划分。 对每个 Object 进行编号，取中间的那个编号的 Object 进行划分，可保证平衡划分。中间编号可以使用==快速选择算法==在 O(n)时间找到。 BVH 伪代码\nIntersect(Ray ray, BVH node) { if (ray misses node.bbox) return; // 光线和BVH节点不相交，直接return if (node is a leaf node) // 叶子节点，光线和其内部所有物体求交，返回最先相交的 test intersection with all objs; return closest intersection; // 中间节点，递归，返回最先相交的 hit1 = Intersect(ray, node.child1); hit2 = Intersect(ray, node.child2); return the closer of hit1, hit2; } 路径追踪 (Path Tracing) 辐射度量学 Basic radiometry\n上述提到的方法均属于 Whitted-Style 光线追踪，由于此方法的光照强度等物理量没有被精确定义，导致最终的结果不真实。辐射度量学用于精确定义与光照相关的物理量，包括精确描述光与物体表面如何作用，精确描述光源、材质、光线的传播方法等物理量。\nRadiant Intensity Definition: The radiant (luminous) intensity is the power per unit solid angle (⽴体⻆) emitted by a point light source. 光源在单位立体角上辐射的能量。\n推导过程如下，其中 r 为到原点的距离，θ 为立体角矢量与 z 轴正向的夹角，Φ 为立体角矢量在 x-y 平面的投影与 x 轴的夹角。r∈[0,+∞)，θ∈[0, π]， φ∈[0,2π]。\n$$ 球坐标中单位球面的定义\\quad {\\rm d} A = (r {\\rm d}θ)(r {\\rm sin}θ {\\rm d}Φ) = r^2 {\\rm sin}θ , {\\rm d}θ {\\rm d}Φ \\ 球坐标中立体角的定义\\quad {\\rm d}ω = {{\\rm d}A \\over r^2} = {\\rm sin}θ , {\\rm d}θ {\\rm d}Φ \\\\ 立体角在整个球面的积分为4π \\ 球面积分\\quad Ω = \\int_{S^2}{\\rm d}ω = \\int_{0}^{2π}\\int_{0}^{π}{\\rm sin}θ , {\\rm d}θ {\\rm d}Φ = 4π \\\\ 假设点光源在各个方向辐射的能量相同，则点光源的整体功率为: \\ Φ = \\int_{S^2} I , {\\rm d}ω = 4πI \\\\ 因此，Radiant \\ Intensity为: \\ I = {Φ \\over 4π} $$\n由上述推到可看出 Radiant Intensity 和到光源的距离无关。立体角的物理意义是在球面空间的某个方向上张开多大的角度。\n立体角 sinθdθdΦ 不光与 dθdΦ 有关，还与 sinθ 有关，说明立体角在球坐标空间中对球面的划分并不平衡，在赤道区域大，在两极区域小。\nIrradiance Definition: The irradiance is the power per (perpendicular/projected) unit area incident on a surface point. 各个方向的光线投影到物体单位表面上的功率。注意这里是投影能量，需要乘以 cosθ。\n$$ E(x) \\equiv {{{\\rm d}Φ(x)} \\over {\\rm d}A} $$\n在距离一个点光源某个固定半径的球面上的 Irradiance 如下所示，其中 E 为 Irradiance, I 为 Radiant Intensity\n$$ E = {Φ \\over 4πr^2} = {I \\over r^2} $$\n由上式可以看出 Irradiance 随着半径增大而衰减。\nRadiance Definition: The radiance (luminance) is the power emitted, reflected, transmitted or received by a surface, per unit solid angle, per projected unit area. 光线传播过程中，在路径中的某个物体的单位表面上沿着某个立体角方向发射的能量。\n$$ L(p,\\omega) \\equiv {{\\rm d}^2\\Phi(p,\\omega) \\over {\\rm d}\\omega {\\rm d}A{\\rm cos}\\theta} \\quad \\text{(cosθ用于计算投影表面积)} $$\nRecall Irradiance: power per projected unit area Intensity: power per solid angle So Radiance: Irradiance per solid angle. 物体单位表面积在某个立体角方向上接收到的能量。 Radiance: Intensity per projected unit area. Radiance 与 Irradiance 的区别在于后者度量物体的单位表面积在所有方向上接收到的能量，而前者只度量某个方向上接收到的能量。\nBRDF Bidirectional Reflectance Distribution Function (BRDF) 双向反射分布函数\nThe Bidirectional Reflectance Distribution Function (BRDF) represents how much light is reflected into each outgoing direction from each incoming direction.\n反射方程 The Reflection Equation\n观察被照射物体表面上一个单位面积，以及从此单位表面积到照相机的矢量。假设此表面积吸收了全部入射光照能量，然后向各个方向发射这些能量。考察这个单位面积上，所有入射光线在这个矢量方向上的反射光照强度贡献。\n渲染方程 Recursive Equation\n$$ L_r(x, \\omega_r) = L_e(x, \\omega_r) + \\int_{\\Omega} L_r(x\u0026rsquo;, -\\omega_i)f(x,\\omega_i,\\omega_r),{\\rm cos}\\theta_i,{\\rm d}\\omega_i $$\n全局光照：直接光照 + 间接光照\n蒙特卡洛路径追踪 Monte Carlo Path Tracing\n蒙特卡洛积分 Monte Carlo Integration\n$$ \\int f(x) {\\rm d}x = {1 \\over N} \\sum_{i=1}^N \\frac{f(X_i)}{p(X_i)} \\quad X_i \\sim p(x) $$\n其中 f(x)是原函数，p(x)是概率密度函数。N 越大(样本量越大)结果越准。不需要考虑积分域，因为概率密度函数隐含了此信息。\n路径追踪 Path Tracing\n一般光线每次弹射后会有无数方向，如果每根弹射光线都要进行计算，则要被计算的光线将会呈指数级增长，导致计算过程中出现路径爆炸的问题，造成计算耗时无限延长。\n由于#rays = N^#bounces^，当 N=1 时不会引发路径爆炸。此时，在对任何一点进行着色时，随机往一个方向采样一个 ω~i~进行渲染方程(PDF)的计算。因此，用 N=1 进行蒙特卡洛积分的方法被称作==路径追踪==。\n一般 N=1 时的蒙特卡洛积分噪声会很大，这可以通过在一个像素点上追踪多根光线解决。只需在每个像素上追踪更多的路径，并计算他们的亮度平均值。\n后续的问题\n用于终止路径追踪递归函数的俄罗斯轮盘赌算法 用于减少无效路径追踪的光源采样法 光源采样法的判断直接光照是否被阻挡算法 对于路径追踪，点光源难以处理，一般简化为面积相对小的面光源 "},{"id":5,"href":"/computer-graphics/","title":"计算机图形学","parent":"Notes","content":" 计算机图形学\n"},{"id":6,"href":"/fuck-gfw/debian-vps/","title":"Debian VPS 配置","parent":"科学上网","content":" XRay 官方脚本安装的文件 模板编辑配置文件 Xray 教程 V2rayN 4.12 配置教程 将语言更改成英语 首先输入下列语句，打开 locale 文件。\nsudo vim /etc/default/locale 显示如下\nLANG=\u0026#34;zh_CN.UTF-8\u0026#34; LANGUAGE=\u0026#34;zh_CN:zh\u0026#34; 将其内容更改成如下内容，然后重启。\nLANG=\u0026#34;en_US.UTF-8\u0026#34; LANGUAGE=\u0026#34;en_US:en\u0026#34; 配置 sudo apt install sudo chmod 777 /etc/sudoers # 将sudoers修改为可编辑权限 vim /etc/sudoers 在root ALL=(ALL:ALL) ALL下添加user ALL=(ALL) ALL\nchmod 440 /etc/sudoers # 将sudoers改回只读权限 配置静态 IP 打开/etc/network/interfaces文件，写入如下信息\niface ens192 inet static address 192.168.7.220 netmask 255.255.255.0 gateway 192.168.7.1 之后输入reboot重启。之后输入/etc/init.d/networking restart重启网络服务。\n修改 GRUB 引导菜单等待时间 编辑/etc/default/grub文件，修改GRUB_TIMEOUT=5 这一参数值， 且保存退出。之后执行sudo update-grub重新生成 GRUB。\nDocker 配置国内源 创建/etc/docker/daemon.json文件，写入如下内容，之后输入sudo systemctl restart docker重启 Docker 服务。\n{ \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;] } "},{"id":7,"href":"/fuck-gfw/","title":"科学上网","parent":"Notes","content":" 科学上网\n"},{"id":8,"href":"/fuck-gfw/soft-routeros/","title":"软路由系统","parent":"科学上网","content":" 概论 软路由配置建议 仅装路由系统：J1900 + 2G 内存 一机多用+功能最大化：支持 VT-d 技术的 CPU + 大内存 =\u0026gt; 虚拟机 VT-d 技术：虚拟化直通技术，LEDE 系统可以绕过虚拟平台，直接使用硬件资源 如需在软路由上玩虚拟化，最好选择 Intel 网卡 硬盘的读写速度不会影响裸装软路由的性能 裸装软路由的内存消耗大约只有 200+MB，大的内存不会提生速度，一般分配 1GB 内存足够 CPU 对软路由的性能起决定性作用，网卡决定了稳定性的好坏 软路由多网口的意义 多条宽带接入，需要多个 WAN 口 软路由内网传输需要消耗一定的 CPU 资源，因此不建议作为交换机使用 性能不好的软路由，最好搭配交换机 软路由 CPU 比较 CPU 频率 规格 功耗 单线程分数 多线程分数 虚拟化技术（VT-x） 定向虚拟化（VT-d） AES 指令集 参考价格 J1900 1.99GHz 4 核 4 线程 10W 535 1839 Y N N 600 起 3205U 1.50GHz 2 核 2 线程 15W 803 1499 Y Y N 750 起 ==3215U== 1.70GHz 2 核 2 线程 15W 915 1641 Y Y N 无货 3855U 1.60GHz 2 核 2 线程 15W 881 1680 Y Y Y 1100 起 3865U 1.80GHz 2 核 2 线程 15W 1016 1898 Y Y Y 1100 起 i3 7100U 2.40GHz 2 核 4 线程 15W 1359 3767 Y Y Y 1800 起 i5 7200U 2.50GHz 2 核 4 线程 15W 1723 4603 Y Y Y 2000 起 i5 7300U 2.60GHz 2 核 4 线程 15W 1963 5188 Y Y Y 2000 起 i7 7500U 2.7 GHz 2 核 4 线程 15W 1916 5154 Y Y Y 2200 起 AES 指令集：科学上网需要加密解密过程，如果 CPU 支持此指令集将大大降低其加密解密负荷。注意，并不是所有支持 AES 的 CPU 都有显著的性能提升。 软路由系统更看重 CPU 的单线程能力，因其对软路由的性能影响最大。 高等级 CPU 只适合折腾虚拟机，否则若只跑软路由将造成性能过剩，因为此时的瓶颈在带宽上（300M）。 虚拟机玩家建议 CPU i3 以上，内存 8G 以上。 LEDE + RouterOS 双软路由系统 LEDE 如果安装插件过多将导致不稳定，因此将其功能分解为两大块：主路由负责网络核心功能，如拨号，多线负载，宽带叠加等；旁路由负责科学上网、去广告等功能。同时，由于两个软路由系统都安装在虚拟机内部，因此它们之间的数据交换也在虚拟机内部完成，不存在所谓硬件连接的性能问题。\n目前主路由系统使用最多的是 iKuai 和 RouterOS。\nRouterOS 内存使用量极低，一般几十 MB 左右，CPU 使用量也极低，普通上网情况下不超过 5%。此外，ROS 还包含拨号上网，DNS 换存等实用功能。最大的缺点是没有科学上网功能。\n旁路由系统，也有人称其为二级路由，但作为旁路由他没有路由功能，作为二级路由他又和主路由在同一网段下，没有隔离网段。因此称其为旁路网关可能更贴切一些。目前带科学上网功能的软路由系统只有两个：KoolShare 的 LEDE，和恩山 L 大的 OpenWrt。上述两个系统都属于 OpenWrt，由于之前的 LEDE 已经合并，因此目前只有 OpenWrt。\n双路由系统的连接 主路由 ROS 只使用两个网口，WAN 连接光猫，LAN 连接无线 AP。在虚拟机内部，两者使用同一个虚拟交换机进行数据交换，旁路由的 LAN 接主路由的 LAN。为了科学上网，需要设置终端设备的网关为旁路由的 IP，让请求数据先经过旁路由。如果设备过多，逐一给终端设备设置网关会很困难，此时可以通过设置主路由的 DHCP 功能解决。主路由的 DHCP 可以自动将旁路由的 IP 分配给终端设备，作为后者的网关。\n请求首先经过无线 AP，通过主路由的 LAN 口到达主路由，之后通过虚拟机内部的交换机到达旁路由。随后，旁路由的科学上网插件处理请求数据（加密），处理完的请求数据需要根据旁路由内部设置的网关发送给下一个目标，因此需要将旁路由的网关设置为主路由的 IP。\n总结：双软路由系统需要将所有终端设备的网关指向旁路由，再将旁路由的网关指向主路由。\n软路由上的虚拟化平台选择 PVE 和 ESXI 是主流的两种软路由虚拟化平台。PVE 的启动速度更快，内存消耗更低，而且不跳硬件。实际使用时，在软路由上网的应用场景下，PVE 的表现不如 ESXI。\n虚拟机系统 ESXi 的安装与设置 相关资源链接和注意事项 vSphere Hypervisor (ESXi 7.x)下载 文档和硬件要求 Rufus - 开源 USB 启动盘制作工具 Exsi7.0 在 256GB 以下存储设备安装无可用空间原因和解决方案\nESXI7.0，第一次进入安装时，按 shift + O 在显示的runweasel cdromBoot后输入autoPartitionOSDataSize=8192注意大小写 8192 表示指定 OSDataSzie 为 8GB，再按 enter 回车进行正常安装即可； 对比 6.7 系统，给出 8GB 完全可以满足 VMware tools、scratch 以及 coredump 空间的需求。 这样指定了空间大小，就不存在自动划分那么大的空间了\n设置硬件直通加速 进入 ESXi 管理页面，选择管理=\u0026gt;硬件，筛选器选择支持直通，勾选除第一个以外的全部网卡，点击切换直通，之后点击重新引导主机重启，完成。此时在网络=\u0026gt;物理网卡页面下只能看到只有一个网卡，之后可以给虚拟机添加直通设备。在创建虚拟机的自定义设置里点击添加其他设备=\u0026gt;PCI 设备，则会自动添加硬件加速的网卡，直到无网卡可用，按钮置灰。之后注意设置内存内勾选预留所有客户机内存(全部锁定)，否则虚拟机无法启动。\n此外，还应打开虚拟交换机的混杂模式，点击网络=\u0026gt;虚拟交换机=\u0026gt;v Switch0=\u0026gt;编辑设置=\u0026gt;安全，将其内部的混杂模式、MAC 地址更改、伪传输全部置为接受。否则只有第一个网口可以访问 ESXi 控制台页面。\niKuai 安装和设置 安装 vmware 安装中建议选择客户机操作系统版本为 ubuntu64 位，否则默认网卡类型是 AMD，该类型的虚拟网卡性能很差。参考文章\n建议配置 1024MB 内存，2GB 硬盘。\n设置 首先设置 DHCP，进入管理页面，点击网络设置=\u0026gt;DHCP 设置=\u0026gt;DHCP 服务端=\u0026gt;添加，设置服务接口为 lan1，客户端地址为 192.168.7.31~192.168.7.200，网关设置为 iKuai 的 Lan 口 IP(如果是双软路由系统需要设置为 lede 的 Lan 口 IP)，首选 DNS 建议设置为光猫的 IP，备选 DNS 设置为 114.114.114.114。点击保存。\n其次设置 wan 口和网桥，点击网络设置=\u0026gt;内外网设置，点击外网网口 wan1，网卡选择 eth3，点击绑定=\u0026gt;保存。点击内网网口 lan1，展开高级设置，在扩展网卡中勾选其余网口，点击保存。\nRouterOS 的安装设置指南 下载和安装 首先需要在官网下载 Cloud Hosted Router 版本的 OVA 安装包。注意 6.x 版本不支持 Intel i211 网卡，因此建议下载 7.x 版本。下载链接 文档\n在 ESXi 上安装过程只需使用 OVA 进行安装即可，注意网卡直通需要锁定客户机内存，硬盘格式可用 SCSI 控制器。由于 ROS 初始安装时网口的顺序随机，安装过程中注意只有 ETH0 接口有网线，否则初始的控制口会被设置为插着网线的其他网口。安装好后可通过以下命令查看相关系统信息。\n# ROS常用命令 interface print # 查看网卡接口 ip address add address=192.168.7.1/24 interface=ether1 # 给网口添加IP地址 ip address remove 0 # 移除接口的IP地址 system reboot # 重启系统 system shutdown # 关闭系统 system reset # 恢复初始状态 ip export # 查看IP配置 ip address print # 同上 system license print # 查看授权 连接和配置 7.x 版本暂不支持 WinBox Mac 地址直连，因此需要先在 ROS 的 shell 环境配置 IP 和网口。默认账号为 admin，无默认密码。\n首先使用interface print命令查看网口信息，之后用ip export查看 IP 信息。然后 ip address add 设置 LAN0 网口的 IP，即当前软路由插着网线的网口 IP。之后可通过浏览器或 WinBox 连接。\n由于目前网口的命名是随机的，首先需要配置 interface，将各个网口命名，尤其注意设置 LAN0 口和 WAN 口。一般一直有流量的口是 LAN0 口，之后可通过插网线到每个端口上看看是否有流量变化确定各个网口。\n设置 DHCP Client。由于软路由连光猫，由光猫负责拨号，因此只需配置 ROS 为 DHCP Clint 即可。进入 IP =\u0026gt; DHCP Client =\u0026gt; Add New，Interface 选择 WAN 口，其余默认，OK。\n设置防火墙的 NAT 设置 (IP 伪装)。进入 IP =\u0026gt; Firewall =\u0026gt; NAT =\u0026gt; Add New =\u0026gt; Action，设置 Action 为 masquerade(伪装)，其余默认，OK。\n设置 DHCP Server。进入 IP =\u0026gt; DHCP Server =\u0026gt; DHCP =\u0026gt; DHCP Setup，依次设置 DHCP Server Interface 为 LAN0；DHCP Address Space 为 192.168.7.0/24；Gateway for DHCP Network 为 192.168.7.1 (ROS 的 IP)；设置 Addresses to Give Out(动态地址分配范围)为 192.168.7.31192.168.7.200；设置 DNS Server 为光猫上的 DNS 地址，同时可以添加一个备用的 114.114.114.114；Lease Time 保持默认。以上操作可一次性设置好 DHCP Server 和 DNS。\n设置网桥连通其他几个 LAN 口。文档 未成功\n设置 DNS 代理。\n激活永久免费试用版。进入 System =\u0026gt; License，点击 Renew License，输入 MikroTik 的账号密码，选择 Level 为 P Unlimited，点击 Start 开始注册，设置完成。此时用此账号登录 MikroTik 官网，在其中的 CHR LICENSES =\u0026gt; All CHR keys，可以找到刚才的注册信息。\nLEDE LEDE 仓库准备 首先 Fork `https://github.com/coolsnowwolf/lede 其次，参考 https://github.com/KFERMercer/OpenWrt-CI，上传openwrt-ci.yml和merge-upstream.yml到刚才Fork的/.github/workflows/下。 由于 Fork 的coolsnowwolf/lede没有 PassWall 组件，需要参考 https://github.com/kenzok8/openwrt-packages，添加相关package到自己的仓库。 编译虚拟机准备 使用 Ubuntu Server 20.04 LTS x64 虚拟机，注意创建时设置 80G 硬盘，且在安装步骤中的 Storage Configuration 页面手动调整 ubuntu-lv 的硬盘大小不小于 60G。配置软件源为http://mirrors.aliyun.com/ubuntu。详细过程可参考Ubuntu 20.04 live server 版安装(详细版)。\n虚拟机创建完成后输入以下命令，参考 https://github.com/coolsnowwolf/lede。\nsudo apt-get update sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch python3 python2.7 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf wget curl swig rsync # 初始化git ssh-keygen git config --global user.name \u0026#34;\u0026lt;username\u0026gt;\u0026#34; git config --global user.email \u0026#34;\u0026lt;username\u0026gt;@***.***\u0026#34; git clone \u0026lt;上一步准备好的lede仓库\u0026gt; # 准备配置菜单 ./scripts/feeds update -a ./scripts/feeds install -a make menuconfig 推荐主题：ifit、Argon、Netgear、Edge。LuCI =\u0026gt; Applications详细配置可参考OpenWrt 编译 LuCI -\u0026gt; Applications 添加插件应用说明-L 大。\n如果是本地编译，则按照 lede 的说明进行操作即可。如果需要使用 Github 的 Action 进行在线编译，则参考 https://github.com/KFERMercer/OpenWrt-CI 进行。\n注意如果在使用 Github 的 Action 时需要定制化 lede，按如下步骤进行。\n# https://github.com/coolsnowwolf/lede/issues/2288 make defconfig ./scripts/diffconfig.sh \u0026gt; seed.config 之后将 seed.config 中的内容复制粘贴到/.github/workflows/openwrt-ci.yml的指定位置中，然后提交。\n# # 在 cat \u0026gt;\u0026gt; .config \u0026lt;\u0026lt;EOF 到 EOF 之间粘贴你的编译配置, 需注意缩进关系 # 例如: cat \u0026gt;\u0026gt; .config \u0026lt;\u0026lt;EOF # 将seed.config的内容粘贴在这里 EOF # # =============================================================== # 在 ESXi7 系统上安装 参考如何在#VMWare #ESXi 6.7 上安装 OpenWrt 虚拟机充当旁路由\n首先，在 ESXi 管理页面打开 SSH，右击主机 =\u0026gt; 服务 =\u0026gt; 启用 Secure Shell (SSH)。\n其次，将编译出的 OpenWrt 镜像openwrt-x86-64-generic-squashfs-combined-efi.vmdk，改名为openwrt.vmdk，上传到 ESXi 存储目录。\n使用 MobaXterm 远程登录到 ESXi Shell 页面，依次输入以下命令\ncd /vmfs/volumes/datastore1/\u0026lt;存放vmdk文件的目录，如iso\u0026gt; # 使用vmkfstools将不支持的.vmdk转换为ESXi支持的.vmdk格式 vmkfstools -i openwrt.vmdk openwrt.esxi7.vmdk # \u0026lt;旧的.vmdk\u0026gt; \u0026lt;新的.esxi7.vmdk\u0026gt; 之后创建虚拟机，选择创建新虚拟机，系统选择其他 Linux64 位，硬件中删除 USB、硬盘，建议内存 2GB。\n创建成功后将之前生成的openwrt.esxi7.vmdk文件==复制到==刚才创建的虚拟机文件夹中，编辑虚拟机，添加硬盘选择刚才的 vmdk 文件，启动虚拟机。之后马上断电，再次编辑虚拟机，将之前的硬盘容量设置为 1GB，启动虚拟机，安装 lede。\n安装完成后应该修改静态 IP 地址，输入vim /etc/config/network，找到 option ipaddr \u0026lsquo;192.168.1.1\u0026rsquo;，修改为你要设定的 IP，保存退出，输入 reboot 重启 OpenWrt。\n路由配置 首先配置旁路由OpenWrt/lede：(默认账号密码为 admin 和 password)\n进入网络 =\u0026gt; 接口，删除其余接口，只保留 Lan 口。点击修改，设置IPv4 网关为主路由 IP(如 192.168.7.1)，IPv4 广播为最后一位置 0 的 IPv4 地址(如 192.168.7.0)，使用自定义的 DNS 服务器设置为光猫的 IP ==(一定要设置)==，同时可添加额外的公共 DNS 服务器，如 114.114.114.114 或 233.5.5.5。禁用此端口的DHCP 服务器功能(勾选忽略此接口)，同时禁用 DHCP IPv6，点击保存\u0026amp;应用。 由于 lede 只作为旁路由使用，防火墙只需在主路由中设置，因此可关闭防火墙，进入网络 =\u0026gt; 防火墙，取消勾选启用 SYN-flood 防御，同时在区域中删除其他网口，只保留 lan 口，点击保存\u0026amp;应用。 之后配置主路由，DHCP 服务端设置网关为旁路由的 IP 即可。\n另外，==(未证实)==，为了能成功实现科学上网，主路由的 DNS 必须指向旁路由**(OpenWrt/lede)**的 IP，使用旁路由进行 DNS 代理。否则，一但科学上网插件出了问题，将导致无法上网。所以需要设置主路由 DHCP 的 DNS 指向旁路由的 IP。\n其他参考资料 轻松编译 Openwrt 固件支持 V2ray 和 Trojan-下篇 编译更新 OpenWrt PassWall 和 SSR-plus 插件 ESXI+ROS+LEDE 问题求解，只有管理口能上网 OpenWrt 使用 KMS 服务激活 Office 首先，必须是 VOL 版本的 windows 和 office 才能使用此法激活。如何区分？注意下载的 ISO 文件是以什么开头，一般 cn 开头的是零售版，sw 开头的是 VOL 版。其次，进入到 Office 的安装目录，如C:\\Program Files (x86)\\Microsoft Office\\Office16。进去这个目录，可以看见有个 OSPP.VBS 文件。然后，以管理员身份打开cmd控制台，输入如下语句。注意此处必须以管理员身份运行。\ncscript ospp.vbs /sethst:192.168.7.2 # 你的OpenWrt路由IP 一般来说，“一句命令已经完成了”，但一般 office 不会马上连接 kms 服务器进行激活，所以我们额外补充一条手动激活命令。（经测试，此步骤可以省略）\ncscript ospp.vbs /act "},{"id":9,"href":"/computer-graphics/games202/","title":"GAMES 202","parent":"计算机图形学","content":"实时渲染：对离线渲染的科学知识的简化和变得更快的方法，以及相关的系统工程。\n实时渲染进化史 Interactive 3D graphics pipeline as in OpenGL\nEarliest SGI machines (Clark 82) to today Most of focus on more geometry, texture mapping Some tweaks for realism (shadow mapping, accum. buffer) 20 years ago\nInteractive 3D geometry with simple texture mapping, fake shadows(OpenGL, DirectX) 20 -\u0026gt; 10 years ago\nA giant leap since the emergence of programmable shaders(2000) ==可编程渲染管线被发布出来== Complex environment lighting, real materials (velvet, satin, paints), soft shadows Today\n“Stuning graphics” Extended to Virtual Reality(VR) and even movies ==以前认为只能使用离线渲染制作电影== In the future \u0026hellip;\u0026hellip;\n技术和算法的里程碑 Programmable graphics hardware (shaders) (20 years ago) ==可编程渲染管线== Precomputation-based methods (15 years ago)\nComplex visual effects are (partially) pre-computed Minium rendering cost at run time Interative Ray Tracing (8-10 years ago: CUDA + OptiX) ==先用很低的采样率生成一些噪声很多的结果，之后降噪，在 GPU 很多的情况下产生较好的结果==\nHard ware development allows ray tracing on GPUs at low sampling rates (~1 samples per pixel (SPP)) Followed by post processing to denoise Graphics (Hardware) Pipeline 几何体 3D 模型 ==\u0026gt; 顶点处理(几何体转换为顶点和连接关系) ==\u0026gt; 光栅化(把原本连续表示的三角形离散为屏幕空间上的一堆像素, Rasterization) ==\u0026gt; 处理遮挡(Fragment Processing) ==\u0026gt; 着色(Framebuffer Operations) ==\u0026gt; 产生图像\nOpenGL 定义 在 CPU 端执行的，负责调度 GPU 进行工作的一系列 API。因此，OpenGL 是语言无关的，用户更关心 GPU 如何执行，而不关系 CPU 如何让 GPU 执行。OpenGL 跨平台，且有其他的替代 API(DirectX, Vulkan, etc.)\n缺点：版本碎片化严重；C 风格，无面向对象特性；Debug 困难。\n如何使用： 将其理解为画油画的过程：\nPlace objects/modes\nModel specification\nModel transformation\nUser spec\nSet Position of an easel\nAttach a canvas to the easel\nPaint to the canvas\n(Attach other canvases to the easel and continue painting)\n(Use previous paintings for reference)\n"},{"id":10,"href":"/fuck-gfw/lvm/","title":"Linux Logical Volume Manager(LVM)详解","parent":"科学上网","content":" LVM 简介 LVM 是 Logical Volume Manager（逻辑卷管理）的简写，它是 Linux 环境下对磁盘分区进行管理的一种机制。LVM 是在磁盘分区和文件系统之间添加的一个逻辑层，来为文件系统屏蔽下层磁盘分区布局，提供一个抽象的盘卷，在盘卷上建立文件系统，来提高磁盘分区管理的灵活性。通过 LVM 系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（volume group），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（logical volumes），并进一步在逻辑卷组上创建文件系统。管理员通过 LVM 可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配，例如按照使用用途进行定义：“DBdata”和“DBSoft”，而不是使用物理磁盘名“sda”和“sdb”或”hda”和”hdb”。而且当系统添加了新的磁盘，通过 LVM 管理员就不必将磁盘的文件移动到新的磁盘上以充分利用新的存储空间，而是直接扩展文件系统跨越磁盘即可。\nLVM 将一个或多个磁盘分区（PV）虚拟为一个卷组（VG），相当于一个大的硬盘，我们可以在上面划分一些逻辑卷（LV）。当卷组的空间不够使用时，可以将新的磁盘分区加入进来。我们还可以从卷组剩余空间上划分一些空间给空间不够用的逻辑卷使用。LVM 模型如下：\n物理卷（PV）被由大小等同的基本单元 PE 组成，一个卷组由一个或多个物理卷组成。逻辑卷建立在卷组上。逻辑卷就相当于非 LVM 系统的磁盘分区，可以在其上创建文件系统。\n下图是磁盘分区、卷组、逻辑卷和文件系统之间的逻辑关系的示意图：\nLVM 基本术语 物理存储介质（The physical media）：这里指系统的存储设备：硬盘，如：/dev/hda、/dev/sda 等等，是存储系统最低层的存储单元。\n物理卷（Physical Volume，PV）：物理卷就是指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如 RAID)，是 LVM 的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与 LVM 相关的管理参数。\n卷组（Volume Group，VG）：LVM 卷组类似于非 LVM 系统中的物理硬盘，其由物理卷组成。可以在卷组上创建一个或多个“LVM 分区”（逻辑卷），LVM 卷组由一个或多个物理卷组成。\n逻辑卷（Logical Volume，LV）：LVM 的逻辑卷类似于非 LVM 系统中的硬盘分区，在逻辑卷之上可以建立文件系统(比如/home 或者/usr 等)。\nPE（Physical Extent）：每一个物理卷被划分为称为 PE(Physical Extents)的基本单元，具有唯一编号的 PE 是可以被 LVM 寻址的最小单元。PE 的大小是可配置的，默认为 4MB。\nLE（Logical Extent）：逻辑卷也被划分为被称为 LE(Logical Extents) 的可被寻址的基本单位。在同一个卷组中，LE 的大小和 PE 是相同的，并且一一对应。\nLVM 添加硬盘 新增一块硬盘，大小为 200G，如下：\nuser@debian:~$ sudo lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT fd0 2:0 1 4K 0 disk sda 8:0 0 40G 0 disk ├─sda1 8:1 0 1G 0 part /boot └─sda2 8:2 0 39G 0 part ├─centos-root 253:0 0 37G 0 lvm / └─centos-swap 253:1 0 2G 0 lvm [SWAP] sdb 8:16 0 200G 0 disk sr0 11:0 1 1024M 0 rom 分区 user@debian:~$ sudo fdisk /dev/sdb #执行此命令，进行分区 Welcome to fdisk (util-linux 2.23.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Device does not contain a recognized partition table Building a new DOS disklabel with disk identifier 0xdf09eb6a. Command (m for help): p #在此输入p Disk /dev/sdb: 214.7 GB, 214748364800 bytes, 419430400 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0xdf09eb6a Device Boot Start End Blocks Id System Command (m for help): n #在此输入n Partition type: p primary (0 primary, 0 extended, 4 free) e extended Select (default p): p Partition number (1-4, default 1): 1 #在此输入1 First sector (2048-419430399, default 2048): #回车 Using default value 2048 Last sector, +sectors or +size{K,M,G} (2048-419430399, default 419430399): #回车 Using default value 419430399 Partition 1 of type Linux and of size 200 GiB is set Command (m for help): t #在此输入t Selected partition 1 Hex code (type L to list all codes): L #在此输入L 0 Empty 24 NEC DOS 81 Minix / old Lin bf Solaris 1 FAT12 27 Hidden NTFS Win 82 Linux swap / So c1 DRDOS/sec (FAT- 2 XENIX root 39 Plan 9 83 Linux c4 DRDOS/sec (FAT- 3 XENIX usr 3c PartitionMagic 84 OS/2 hidden C: c6 DRDOS/sec (FAT- 4 FAT16 \u0026lt;32M 40 Venix 80286 85 Linux extended c7 Syrinx 5 Extended 41 PPC PReP Boot 86 NTFS volume set da Non-FS data 6 FAT16 42 SFS 87 NTFS volume set db CP/M / CTOS / . 7 HPFS/NTFS/exFAT 4d QNX4.x 88 Linux plaintext de Dell Utility 8 AIX 4e QNX4.x 2nd part 8e Linux LVM df BootIt 9 AIX bootable 4f QNX4.x 3rd part 93 Amoeba e1 DOS access a OS/2 Boot Manag 50 OnTrack DM 94 Amoeba BBT e3 DOS R/O b W95 FAT32 51 OnTrack DM6 Aux 9f BSD/OS e4 SpeedStor c W95 FAT32 (LBA) 52 CP/M a0 IBM Thinkpad hi eb BeOS fs e W95 FAT16 (LBA) 53 OnTrack DM6 Aux a5 FreeBSD ee GPT f W95 Ext\u0026#39;d (LBA) 54 OnTrackDM6 a6 OpenBSD ef EFI (FAT-12/16/ 10 OPUS 55 EZ-Drive a7 NeXTSTEP f0 Linux/PA-RISC b 11 Hidden FAT12 56 Golden Bow a8 Darwin UFS f1 SpeedStor 12 Compaq diagnost 5c Priam Edisk a9 NetBSD f4 SpeedStor 14 Hidden FAT16 \u0026lt;3 61 SpeedStor ab Darwin boot f2 DOS secondary 16 Hidden FAT16 63 GNU HURD or Sys af HFS / HFS+ fb VMware VMFS 17 Hidden HPFS/NTF 64 Novell Netware b7 BSDI fs fc VMware VMKCORE 18 AST SmartSleep 65 Novell Netware b8 BSDI swap fd Linux raid auto 1b Hidden W95 FAT3 70 DiskSecure Mult bb Boot Wizard hid fe LANstep 1c Hidden W95 FAT3 75 PC/IX be Solaris boot ff BBT 1e Hidden W95 FAT1 80 Old Minix Hex code (type L to list all codes): 8e #输入lvm类型的hex代码 Changed type of partition \u0026#39;Linux\u0026#39; to \u0026#39;Linux LVM\u0026#39; Command (m for help): p #在此输入p Disk /dev/sdb: 214.7 GB, 214748364800 bytes, 419430400 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0xdf09eb6a Device Boot Start End Blocks Id System /dev/sdb1 2048 419430399 209714176 8e Linux LVM Command (m for help): w #保存 The partition table has been altered! Calling ioctl() to re-read partition table. Syncing disks. 创建物理卷（Physical Volume，PV） 查看是否以分好区\nuser@debian:~$ sudo lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT fd0 2:0 1 4K 0 disk sda 8:0 0 40G 0 disk ├─sda1 8:1 0 1G 0 part /boot └─sda2 8:2 0 39G 0 part ├─centos-root 253:0 0 37G 0 lvm / └─centos-swap 253:1 0 2G 0 lvm [SWAP] sdb 8:16 0 200G 0 disk └─sdb1 8:17 0 200G 0 part sr0 11:0 1 1024M 0 rom 创建物理卷 PV\nuser@debian:~$ sudo pvcreate /dev/sdb1 Physical volume \u0026#34;/dev/sdb1\u0026#34; successfully created. 查看物理卷创建情况\nuser@debian:~$ sudo pvdisplay --- Physical volume --- PV Name /dev/sda2 VG Name centos PV Size \u0026lt;39.00 GiB / not usable 3.00 MiB Allocatable yes PE Size 4.00 MiB Total PE 9983 Free PE 1 Allocated PE 9982 PV UUID jYS4Ia-7Hy9-2r9n-QGqg-Uw2I-B8D7-mQLcoR \u0026#34;/dev/sdb1\u0026#34; is a new physical volume of \u0026#34;\u0026lt;200.00 GiB\u0026#34; --- NEW Physical volume --- PV Name /dev/sdb1 #这里是我们刚创建的物理卷 VG Name PV Size \u0026lt;200.00 GiB Allocatable NO PE Size 0 Total PE 0 Free PE 0 Allocated PE 0 PV UUID NGD0Ox-9ezO-vXk2-xlgo-VuqM-be8n-LBVxtj 使用刚创建的物理卷 PV 创建新的卷组（Volume Group，VG） 创建新卷组 创建卷组的命令为 vgcreate，下面利用它创建了一个名为“debian-vg-2”的卷组，该卷组包含/dev/sdb1、/dev/sdc1 两个物理卷。\nuser@debian:~$ sudo vgcreate debian-vg-2 /dev/sdb1 /dev/sdc1 Volume group \u0026#34;debian-vg-2\u0026#34; successfully created 注意：对于 LVM1，由于受内核限制的原因，一个逻辑卷（Logic Volume）最多只能包含 65536 个 PE（Physical Extent），所以一个 PE 的大小就决定了逻辑卷的最大容量，4 MB 的 PE 决定了单个逻辑卷最大容量为 256 GB，若希望使用大于 256G 的逻辑卷，则创建卷组时需要指定更大的 PE。在 Red Hat Enterprise Linux AS 4 中 PE 大小范围为 8 KB 到 16GB，并且必须总是 2 的倍数。例如，如果希望使用 64 MB 的 PE 创建卷组，这样逻辑卷最大容量就可以为 4 TB 。如果希望创建一个使用全部卷组的逻辑卷，则需要首先通过 vgdisplay 察看该卷组的 Total PE 数，然后在创建逻辑卷时指定。以上仅 lvm1 对此有限制，lvm2 无此限制。\n查看创建的卷组：\nuser@debian:~$ sudo vgdisplay --- Volume group --- VG Name debian-vg-2 System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 2 VG Access read/write VG Status resizable MAX LV 0 Cur LV 1 Open LV 1 Max PV 0 Cur PV 1 Act PV 1 VG Size \u0026lt;500.00 GiB PE Size 4.00 MiB Total PE 127999 Alloc PE / Size 76800 / 300.00 GiB Free PE / Size 51199 / \u0026lt;200.00 GiB VG UUID RC9Kbc-g3gc-ilcL-o3a0-AnVP-N1xk-Yo9eS9 激活刚刚创建的卷组，否则 df -h 命令无法看到。\nuser@debian:~$ sudo vgchange -a y debian-vg-2 0 logical volume(s) in volume group \u0026#34;debian-vg-2\u0026#34; now active 创建新的逻辑卷（Logical Volume，LV）并挂载 创建逻辑卷\nuser@debian:~$ sudo lvcreate -L 15G -n data debian-vg-2 Logical volume \u0026#34;data\u0026#34; created 查看新创建的 LV\nuser@debian:~$ sudo lvisplay --- Logical volume --- LV Path /dev/debian-vg-2/data LV Name data VG Name debian-vg-2 LV UUID diuGxk-0COv-P2lk-y0qV-D6XY-MjKE-ed1VvU LV Write Access read/write LV Creation host, time debian, 2022-08-27 22:39:23 +0800 LV Status available # open 1 LV Size 300.00 GiB Current LE 76800 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 256 Block device 254:2 将新创建的逻辑卷激活并挂载\nuser@debian:~$ sudo mount /dev/sdb1 /data 以上命令每次重启电脑后都会丢失，导致开机启动程序失败，因此需要修改/etc/fstab，实现开机自动挂载。\nuser@debian:~$ sudo vim /etc/fstab 打开文件，在最下面一行添加如下语句，保存退出。\n/dev/mapper/debian--vg--2-data /data ext4 defaults 0 2 此文件的详细介绍可参考/etc/fstab 文件详解。\n使用刚创建的物理卷 PV 扩展已有卷组（Volume Group，VG） 查看卷组情况\nuser@debian:~$ sudo vgdisplay --- Volume group --- VG Name debian-vg-2 #卷组的名称 System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 3 VG Access read/write VG Status resizable MAX LV 0 Cur LV 2 Open LV 2 Max PV 0 Cur PV 1 Act PV 1 VG Size \u0026lt;39.00 GiB PE Size 4.00 MiB Total PE 9983 Alloc PE / Size 9982 / 38.99 GiB Free PE / Size 1 / 4.00 MiB VG UUID oIgyce-IO2t-FegU-Kgvb-n2Us-6K3u-rbJCdy 将新的分区/dev/sdb1 加入到卷组中，这里的卷组名为 centos\nuser@debian:~$ sudo vgextend centos /dev/sdb1 Volume group \u0026#34;centos\u0026#34; successfully extended 添加完成后再次查看卷组信息\nuser@debian:~$ sudo vgdisplay --- Volume group --- VG Name debian-vg-2os System ID Format lvm2 Metadata Areas 2 Metadata Sequence No 4 VG Access read/write VG Status resizable MAX LV 0 Cur LV 2 Open LV 2 Max PV 0 Cur PV 2 Act PV 2 VG Size 238.99 GiB #可以看到容量已经增加了200G PE Size 4.00 MiB Total PE 61182 Alloc PE / Size 9982 / 38.99 GiB Free PE / Size 51200 / 200.00 GiB VG UUID oIgyce-IO2t-FegU-Kgvb-n2Us-6K3u-rbJCdy 扩容已有分区 下面是对现有分区进行逻辑卷扩容，我们这里根分区为 40G，我们准备扩容根分区 查看根分区的 LV 路径\nuser@debian:~$ sudo df -h Filesystem Size Used Avail Use% Mounted on devtmpfs 7.8G 0 7.8G 0% /dev tmpfs 7.8G 0 7.8G 0% /dev/shm tmpfs 7.8G 8.9M 7.8G 1% /run tmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup /dev/mapper/centos-root 37G 1.7G 36G 5% / /dev/sda1 1014M 179M 836M 18% /boot tmpfs 1.6G 0 1.6G 0% /run/user/0 或者通过 lvdisplay 一样可以查看，这里的路径为/dev/mapper/centos-root，下面进行扩容\nuser@debian:~$ sudo lvextend -l +100%FREE /dev/mapper/centos-root Size of logical volume centos/root changed from 36.99 GiB (9470 extents) to 236.99 GiB (60670 extents). Logical volume centos/root successfully resized. 查看扩容后的逻辑卷大小\nuser@debian:~$ sudo lvdisplay /dev/mapper/centos-root --- Logical volume --- LV Path /dev/centos/root LV Name root VG Name centos LV UUID tnXHPR-Abe6-BNL4-6EdH-bgZI-UgDM-BfCHrm LV Write Access read/write LV Creation host, time localhost, 2019-09-23 17:31:21 +0800 LV Status available # open 1 LV Size 236.99 GiB Current LE 60670 Segments 2 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:0 然后使用 xfs_groupfs 进行在线调整 xfs 格式的文件系统大小\nuser@debian:~$ sudo xfs_growfs /dev/mapper/centos-root meta-data=/dev/mapper/centos-root isize=512 agcount=4, agsize=2424320 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0 spinodes=0 data = bsize=4096 blocks=9697280, imaxpct=25 = sunit=0 swidth=0 blks naming =version 2 bsize=4096 ascii-ci=0 ftype=1 log =internal bsize=4096 blocks=4735, version=2 = sectsz=512 sunit=0 blks, lazy-count=1 realtime =none extsz=4096 blocks=0, rtextents=0 data blocks changed from 9697280 to 62126080 最后查看下根分区的大小是否扩容成功\nuser@debian:~$ sudo df -h Filesystem Size Used Avail Use% Mounted on devtmpfs 7.8G 0 7.8G 0% /dev tmpfs 7.8G 0 7.8G 0% /dev/shm tmpfs 7.8G 8.9M 7.8G 1% /run tmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup /dev/mapper/centos-root 237G 1.7G 236G 1% / /dev/sda1 1014M 179M 836M 18% /boot tmpfs 1.6G 0 1.6G 0% /run/user/0 参考文章 LVM 添加硬盘并扩容至已有分区 LVM 原理及 PV、VG、LV、PE、LE 关系图 Debian 设置允许 root 用户以 ssh 方式登录 - 掘金 Linx 卷管理详解 VG LV PV Linux 启动自动 mount_Linux 教程_Linux 公社-Linux 系统门户网站 linux 如何 mount 挂载磁盘并设置开机自动 mount神芷迦蓝寺的博客-CSDN 博客自动 mount /etc/fstab 文件的详解韩帅平的博客-CSDN 博客/etc/fstab /etc/fstab 文件详解 "},{"id":11,"href":"/tags/","title":"Tags","parent":"Notes","content":""}]